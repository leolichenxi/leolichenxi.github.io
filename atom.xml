<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CXGame</title>
  
  
  <link href="https://leolichenxi.github.io/atom.xml" rel="self"/>
  
  <link href="https://leolichenxi.github.io/"/>
  <updated>2023-12-22T06:42:15.269Z</updated>
  <id>https://leolichenxi.github.io/</id>
  
  <author>
    <name>李晨曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JetBrains</title>
    <link href="https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E8%AE%BE%E7%BD%AE/"/>
    <id>https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E8%AE%BE%E7%BD%AE/</id>
    <published>2023-12-22T04:00:00.000Z</published>
    <updated>2023-12-22T06:42:15.269Z</updated>
    
    <content type="html"><![CDATA[<p>作为JetBrains系列深度依赖用户者,备注一下使用</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h3><p>安装得.exe 一般有个 .properties  尾缀，修改配置自己设置的缓存路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment this option if you want to customize a path to the settings directory.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">idea.config.path=D:\Caches\JetBrains/.IdeaIC/config</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize a path to the caches directory.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">idea.system.path=D:\Caches\JetBrains/.IdeaIC/system</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="换行设置"><a href="#换行设置" class="headerlink" title="换行设置"></a>换行设置</h3><p>默认宽度 12  可设置</p><p><img src="/2023/12/22/Tools/JetBrains%E8%AE%BE%E7%BD%AE/rider_code_style.png" alt="换行设置"></p><h3 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h3><p><img src="/2023/12/22/Tools/JetBrains%E8%AE%BE%E7%BD%AE/rider_set_update.png" alt="关闭自动更新"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为JetBrains系列深度依赖用户者,备注一下使用&lt;/p&gt;
&lt;h2 id=&quot;设置&quot;&gt;&lt;a href=&quot;#设置&quot; class=&quot;headerlink&quot; title=&quot;设置&quot;&gt;&lt;/a&gt;设置&lt;/h2&gt;&lt;h3 id=&quot;缓存设置&quot;&gt;&lt;a href=&quot;#缓存设置&quot; class=&quot;h</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="JetBrains" scheme="https://leolichenxi.github.io/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>VSCode</title>
    <link href="https://leolichenxi.github.io/2023/12/22/Tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://leolichenxi.github.io/2023/12/22/Tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2023-12-22T04:00:00.000Z</published>
    <updated>2023-12-22T06:32:32.545Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a><br>##Window<br><img src="/2023/12/22/Tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/window.png" alt="window"></p><p>##Mac<br><img src="/2023/12/22/Tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/mac.png" alt="mac"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf&quot;&gt;https://code.visualstudio.com/shortcuts/keyboard-shortcu</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="VSCode" scheme="https://leolichenxi.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains</title>
    <link href="https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2023-12-22T04:00:00.000Z</published>
    <updated>2023-12-22T06:36:53.920Z</updated>
    
    <content type="html"><![CDATA[<p>==Ctrl==</p><p>Ctrl + A 全选<br>Ctrl + B 快速打开光标处的类或方法(等同于 Ctrl + 鼠标点击)<br>Ctrl + C 复制（不选定内容的话默认会复制光标所在整行）<br>Ctrl + D 复制行或是块（不选定内容的话默认复制当前行到下一行）<br>Ctrl + E 最近打开的文件<br>Ctrl + F 当前代码中查找<br>Ctrl + G 跳到指定行<br>Ctrl + H 显示类层次图<br>Ctrl + J 自动代码提示（提示的是自己定义的代码格式）<br>Ctrl + K git 或 VCS 提交项目<br>Ctrl + L 查看变量的下一个位置（需要先 Ctrl + F 激活查找）<br>Ctrl + M 将光标所在的行移到屏幕中间（连同光标一块移动到屏幕中间）<br>Ctrl + N 查找类<br>Ctrl + O 选择可覆盖/继承的方法<br>Ctrl + P 方法参数提示显示（只显示入参的）<br>Ctrl + Q 鼠标放在变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容。（入参，返回值，所属模块等）<br>         同类似的功能还有一个 Ctrl + Shift + I，直接显示函数定义处的内容（所以 Ctrl + P，Ctrl + Q 和 Ctrl + Shift + I<br>         的查看是一个渐进详细的过程）<br>Ctrl + R 替换<br>Ctrl + S 保存<br>Ctrl + T git 或 VCS 更新项目<br>Ctrl + U 前往父类的方法/父类<br>Ctrl + V 粘贴<br>Ctrl + W 选中光标所在的单词 ，连续按会有其他效果 (相反的是Ctrl+Shift+W)<br>ctrl + X 剪切行<br>Ctrl + Y 删除行<br>Ctrl + Z 撤销</p><p>Ctrl + F1 显示错误<br>Ctrl + F3 调转到所选中的词的下一个同名位置<br>Ctrl + F7 Find Usages in File（可以同时查找多个变量）<br>Ctrl + F8 打开或关闭行断点<br>Ctrl + F9 编译<br>Ctrl + F11 弹出一个小框来指定式添加书签(可以对文件或文件夹起作用)<br>Ctrl + F12 当前编辑的文件中快速导航(可以直接键入字母，会筛选你输入的来匹配对应是否有的方法，来快速定位)(类似结构图)<br>Ctrl + Tab 编辑窗口切换 (如果在切换的过程又加按上 delete,则是关闭对应选中的窗口)<br>Ctrl + delete 删除光标后面的单词（delete 只是删除单个字符哟！）<br>Ctrl + home/end 跳到文件头文件尾<br>Ctrl + BackSpace 删除光标前面的单词<br>Ctrl + [ 或 ] 移动光标到块的初/末括号地方<br>Ctrl + / 或 Ctrl+Shift+/ 注释（// 或者/<em>…</em>/ ）<br>Ctrl + 1，2，3，4…. 快速定位到书签代码处(必须先 Ctrl + Shift + 1,2,3,4…添加书签<br>Ctrl + 小键盘+/- 折叠/展开代码<br>Ctrl + 鼠标单击编辑窗口的文件标题 弹出该文件路径,可以通过这个打开文件所在地方(相当于Ctrl + Alt + F12)<br>Ctrl + ← 或 → 光标跳到上/下个单词<br>Ctrl + ↑ 或 ↓ 相当于你用鼠标滑滚轮(为了方便鼠标党)<br>Ctrl + ` 快速切换常用设置</p><p>==Alt==</p><p>Alt + 1 切换到 Project 模块<br>Alt + 2 切换到 Favorites 模块<br>Alt + 3 切换到 Find 模块<br>Alt + 4 切换到 Run 模块<br>Alt + 5 切换到 Debug 模块<br>Alt + 6 切换到 Problems 模块<br>Alt + 7 切换到 Structure 模块<br>Alt + 8 切换到 Services 模块<br>Alt + 9 切换到 Git 模块<br>Alt + Q Context Info（上下文信息，可以快速帮你定位当前位置的上下文）<br>Alt + F1 弹出文件选择目标，这个很好用的<br>Alt + F2 多个浏览器预览<br>Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示（类似于 Ctrl + C， Ctrl + F）。<br>Alt + F4 关闭软件<br>Alt + F7 查看该方法/变量/类被调用的地方<br>Alt + F8 在debug 的状态下，选中某些变量或是对象，按此快捷键弹出可输入变量、方法的调试框，指定查看该内容的 debug 情况<br>Alt + F12 进入终端<br>Alt + Home 跳到文件导航bar<br>Alt + Insert 生成代码(如 get,set 方法,构造函数等)<br>Alt + ← 或 → 切换当前打开的代码文件视图<br>Alt + ↑ 或 ↓ 在方法间快速移动定位<br>Alt + Enter 快速修复(可以用来导入单个包)<br>Alt + ` VCS快捷选项</p><p>==Shift==</p><p>Shift + F6  重构：重新命名<br>Shift + F9 debug 当前程序，相当于点击 debug 按钮<br>Shift + F10 Run(运行)当前程序，相当于点击 run 按钮<br>Shift + F11 查看书签<br>Shift + end 选中从光标到end 处<br>Shift + home 选中从光标到 home 处<br>Shift + Enter 光标所在行下空出一行，光标跳下<br>Shift + 单击 可以关闭文件<br>Shift + 滚轮 横向滚动轴滚动(非常强大，现在好多文本编辑器都默认有这个功能了)</p><p>==Ctrl+Alt==</p><p>Ctrl + Alt + A git add (需要先配置 git)<br>Ctrl + Alt + B 跳到具体的实现方法，查找接口/抽象方法的具体实现很好用(相反行为的快捷键是Ctrl+b)<br>Ctrl + Alt + C 快速引进一个常量<br>Ctrl + Alt + F 快速引进一个实例变量<br>Ctrl + Alt + I 选中部分自动缩进行（有点类似格式化，但是只是整理行格式而已）<br>Ctrl + Alt + L 格式化代码<br>Ctrl + Alt + M 方法抽取/重构<br>Ctrl + Alt + N 将方法内联化<br>Ctrl + Alt + O 优化导入的类和包<br>Ctrl + Alt + P 参数抽取<br>Ctrl + Alt + S 快速打开设置 Settings<br>Ctrl + Alt + T 选中的地方代码环绕提示 例如 ：try/catch 选中的一块代码<br>Ctrl + Alt + V 快速引进一个变量名<br>Ctrl + Alt + W 关闭所有编辑的快捷键（自己添加，再 close all）<br>Ctrl + Alt + Y 从磁盘重载<br>Ctrl + Alt + Z git rollback (需要先配置 git)<br>Ctrl + Alt + F5 Attach to Process<br>Ctrl + Alt + F7 寻找被该类或是变量被使用的地方，用弹出框的方式找出来，，也类似于 Ctrl + 鼠标 左击。跟 Alt+F7 效果一样，但是因为是弹出框，选中了一个位置就会消失。<br>Ctrl + Alt + F12 文件路径<br>Ctrl + Alt + Enter 光标所在行上空出一行，光标跳上<br>Ctrl + Alt + home 弹出跟当前文件有关联的文件目录(比如jsp 里面有导入几个js 和 css,这些文件就是关联文件)<br>Ctrl + Alt + ← 或 →  退回/前进到上一个操作的地方<br>Ctrl + Alt + ↑ 或 ↓ 在 Find 模式下，挑到上/下个查找的文件<br>Ctrl + Alt + 空格 类名或接口名提示(可能会和输入法快捷键冲突)</p><p>==Ctrl+Shift==</p><p>Ctrl + Shift + A Find Action<br>Ctrl + Shift + B 变量类型声明<br>Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板<br>Ctrl + Shift + E 最近更改的文件<br>Ctrl + Shift + F 全局查找文件（通过某个词，指定要搜索的文件类型，目录。注意：这个也可能会和 Windows 的简繁切换快捷键相冲突哟！！！）<br>Ctrl + Shift + I 在方法名或是类名下，按此快捷键显示该方法或是类的源码结构，无需点击进去查看源码（当然了，必须是你已经导入源码的情况下才看得到）<br>Ctrl + Shift + J 自动将下一行合并到当前行末尾<br>Ctrl + Shift + K git push<br>Ctrl + Shift + M 光标位置在括号前后切换<br>Ctrl + Shift + N 通过输入文件名和行号（可以输入部分名称，支持模糊）来定位查找文件<br>Double + Shift (快速双击 Shift)搜索最近打开的文件，我也是经常误触才发现他这个功能<br>Ctrl + Shift + P 表达式的类型信息<br>Ctrl + Shift + R 搜索指定范围文件，替换文字<br>Ctrl + Shift + T 如果在常规类下按它，弹出已写好的，可选择的对应 Test 类，如果在该 Test 类下按它，则直接回到源类。<br>Ctrl + Shift + U // 大/小写都是这个快捷键<br>Ctrl + Shift + V 粘贴最近复制过的一些信息（从历史记录粘贴）<br>Ctrl + Shift + W Ctrl + W 的逆向操作<br>Ctrl + Shift + Y Code With Me<br>Ctrl + Shift + Z 取消撤销（恢复上一次操作）<br>Ctrl + Shift + F7 高亮显示所有该选中文本，按 Esc 高亮消失。<br>Ctrl + Shift + F8 查看断点<br>Ctrl + Shift + F12 编辑器全屏<br>Ctrl + Shift + Del 删除环绕的标签<br>Ctrl + Shift + 1，2，3… 快速添加书签<br>Ctrl + Shift + Space 自动补全代码（智能提示）<br>Ctrl + Shift + Enter 自动给末尾加;完成代码<br>Ctrl + Shift + ↑ 或 ↓ 移动光标所在 statement 域移动到上/下 (Alt + Shift + ↑ 或 ↓ 移动光标所在行到上/下)<br>Ctrl + Shift + [ 或 ] 选中从光标所在位置到它的父级区域(界面上层导航可能更开)<br>Ctrl + Shift + 小键盘 + 或 – 折叠/展开所有代码<br>Ctrl + Shift + ← 或 →  选中临边左/右的单词或是符号<br>Ctrl + Shift + / 块注释（使用 =begin block =end 进行注释）<br>Ctrl + Shift + Backspace(退格)  回到上次修改的地方(跟 Ctrl+Alt+左右方向键不一样的地方是，只回退到修改的地方，而不是过去光标放的地方)</p><p>==Alt+Shift==</p><p>Alt + Shfit + B 查看当前行对应的 commit 提交记录详情<br>Alt + Shift + C 查看最近操作项目的变化情况列表(在版本控制下，显示比较缓慢)<br>Alt + Shift + F 添加到收藏夹<br>Alt + Shift + G 进入多行选取模式并将光标放在所选行的末尾(简单理解就是，选中多行之后使用这个快捷键，你可以同时往这多行末尾添加相同的内容，感觉和列模式有些像，但列模式不同行的光标都在同一列，这块不同行的光标可以不在同一列 —— 都在各自行的末尾)<br>Alt + Shift + J 取消选中（有点像 Ctrl + Alt + Shift + J 的逆操作，不过 Alt + Shift + J 每次只取消选中一个地方）<br>Alt + Shift + L 加载上下文<br>Alt + Shift + N 添加任务<br>Alt + Shift + S 保存上下文<br>Alt + Shift + T 切换任务<br>Alt + Shift + U 驼峰命名法和蛇形命名法切换(需要先选中方法名对应的字符串)<br>Alt + Shift + W 关闭活跃任务<br>Alt + Shift + X 清理上下文<br>Alt + Shift + F9  弹出debug 运行菜单，提供选择性debug 哪个(这个需要自己尝试下，按后会有弹出框，记得查看)<br>Alt + Shift + F10 弹出run 菜单，提供选择性run 哪个(这个需要自己尝试下，按后会有弹出框，记得查看)<br>Alt + Shift + ↑ 或 ↓ 移动光标所在行到上/下<br>Alt + Shift + Insert 切换到列选择模式（再次可切换回行选择模式）<br>Alt + Shift + 鼠标左键单击不放,拖动 可以直接方块区域选择（也叫列选或块选，批量修改列的时候很有用）</p><p>==Ctrl+Alt+Shift==  （用得不多，因为总感觉手指头不太够用）</p><p>Ctrl + Alt + Shift + C 复制参考信息(方法的继承关系，或文件相对路径及当前所在行号)<br>Ctrl + Alt + Shift + D 以 UML 的形式显示改动<br>Ctrl + Alt + Shift + L 格式化文件<br>Ctrl + Alt + Shift + J 选中所有用到当前方法的地方（这个用来统一修改函数名和调用点函数名之类的很有用，就不用单独一个个去修改了）<br>Ctrl + Alt + Shift + N 查找类中的方法或变量<br>Ctrl + Alt + Shift + T 选择重构方式<br>Ctrl + Alt + Shift + V 不带格式的简单黏贴<br>Ctrl + Alt + Shift + X Deployment -&gt; Upload to (上传文件改动到指定服务器，对于将本地文件改动快速同步到远端服务器的时候很好用)<br>Ctrl + Alt + Shift + F7 Find Usages Settings<br>Ctrl + Alt + Shift + F8 添加临时行断点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==Ctrl==&lt;/p&gt;
&lt;p&gt;Ctrl + A 全选&lt;br&gt;Ctrl + B 快速打开光标处的类或方法(等同于 Ctrl + 鼠标点击)&lt;br&gt;Ctrl + C 复制（不选定内容的话默认会复制光标所在整行）&lt;br&gt;Ctrl + D 复制行或是块（不选定内容的话默认复制当前</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="JetBrains" scheme="https://leolichenxi.github.io/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>adb常用命令记录</title>
    <link href="https://leolichenxi.github.io/2023/12/22/Shell/adb/"/>
    <id>https://leolichenxi.github.io/2023/12/22/Shell/adb/</id>
    <published>2023-12-22T04:00:00.000Z</published>
    <updated>2023-12-22T07:35:07.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="left">指令</th><th align="left">作用</th><th align="left">eg</th></tr></thead><tbody><tr><td align="left">adb devices</td><td align="left">查看连接设备</td><td align="left"></td></tr><tr><td align="left">adb install apk路径</td><td align="left">安装应用</td><td align="left">adb install test.apk</td></tr><tr><td align="left">adb install -r apk路径</td><td align="left">安装apk 到sd 卡</td><td align="left">adb install -r demo.apk</td></tr><tr><td align="left">adb uninstall 包名</td><td align="left">卸载应用，需要指定包</td><td align="left">adb uninstall cn.com.test.mobile</td></tr><tr><td align="left">adb uninstall -k 包名</td><td align="left">卸载app 但保留数据和缓存文件</td><td align="left">adb uninstall -k cn.com.test.mobile</td></tr><tr><td align="left">adb shell pm list packages</td><td align="left">列出手机装的所有app 的包名</td><td align="left"></td></tr><tr><td align="left">adb shell pm list packages -3</td><td align="left">列出除了系统应用的第三方应用包名</td><td align="left"></td></tr><tr><td align="left">adb shell pm clear cn.com.test.mobile</td><td align="left">清除应用数据与缓存</td><td align="left"></td></tr><tr><td align="left">adb shell am start -ncn.com.test.mobile/.ui.SplashActivity</td><td align="left">启动应用</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys package</td><td align="left">包信息Package Information</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys meminfo</td><td align="left">内存使用情况Memory Usage</td><td align="left"></td></tr><tr><td align="left">adb shell am force-stop cn.com.test.mobile</td><td align="left">强制停止应用</td><td align="left"></td></tr><tr><td align="left">adb logcat</td><td align="left">查看日志</td><td align="left"></td></tr><tr><td align="left">adb logcat -c</td><td align="left">清除log 缓存</td><td align="left"></td></tr><tr><td align="left">adb reboot</td><td align="left">重启</td><td align="left"></td></tr><tr><td align="left">adb get-serialno</td><td align="left">获取序列号</td><td align="left"></td></tr><tr><td align="left">adb shell getprop ro.build.version.release</td><td align="left">查看Android 系统版本</td><td align="left"></td></tr><tr><td align="left">adb shell top -s 10</td><td align="left">查看占用内存前10 的app</td><td align="left"></td></tr><tr><td align="left">adb push <local> <remote></remote></local></td><td align="left">从本地复制文件到设备</td><td align="left"></td></tr><tr><td align="left">adb pull <remote> <local></local></remote></td><td align="left">从设备复制文件到本地</td><td align="left"></td></tr><tr><td align="left">adb bugreport</td><td align="left">查看bug 报告</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys battery</td><td align="left">手机电量信息</td><td align="left"></td></tr><tr><td align="left">adb logcat -v time &gt; D:\logs\logcat.log</td><td align="left">输出实时日志并保存在本地文件，通过Ctrl+C来停止。抓取日志的步骤：先输入命令启动日志，然后操作App，复现bug，再ctrl+c停止日志，分析本地保存的文件</td><td align="left"></td></tr></tbody></table><h3 id="系统操作指令"><a href="#系统操作指令" class="headerlink" title="系统操作指令"></a>系统操作指令</h3><table><thead><tr><th align="left">指令</th><th align="left">作用</th><th align="left">eg</th></tr></thead><tbody><tr><td align="left">adb shell getprop ro.product.model</td><td align="left">获取设备型号</td><td align="left"></td></tr><tr><td align="left">adb shell getprop ro.build.version.release</td><td align="left">获取设备android系统版本</td><td align="left"></td></tr><tr><td align="left">adb get-serialno</td><td align="left">获取设备的序列号（设备号）</td><td align="left"></td></tr><tr><td align="left">adb shell wm size</td><td align="left">获取设备屏幕分辨率</td><td align="left"></td></tr><tr><td align="left">adb shell screencap -p /sdcard/mms.png</td><td align="left">屏幕截图</td><td align="left"></td></tr><tr><td align="left">adb pull /sdcard/mms.png D:\app</td><td align="left">将截图导出到本地</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys activity</td><td align="left">获取当前 Android 系统 Activity 栈中 Activity 信息</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys activity top</td><td align="left">获取当前 Android 系统 中与用户交互的 Activity 的详细信息</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys meminfo [应用包名]</td><td align="left">查看应用的内存使用情况</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys package [应用报名]</td><td align="left">获取手机里面某个 apk 的应用信息、版本信息</td><td align="left"></td></tr><tr><td align="left">adb shell dumpsys activity activities</td><td align="left">显示当前所有在运行的任务栈，并可查看栈中所有的 Activity 的列表</td><td align="left"></td></tr></tbody></table><h2 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h2><p>adb [-d-e-s <serialNumber>] <command><br>连接指定设备<br>参数：</serialNumber></p><ul><li><p>-d 指定当前唯一通过USB 连接的Android 设备为命令目标</p></li><li><p>-e 指定当前唯一运行的模拟器为命令目标</p></li><li><p>-s <serialNumber> 指定相应serialNumber 号的设备/模拟器为命令目标</serialNumber></p></li></ul><p>command 为所需对设备执行的命令</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">cf263b7f device</span><br><span class="line">emulator-5554 offline</span><br><span class="line">192.168.1.6:5555 device</span><br><span class="line">$adb -s cf263b7f #连接cf264b8f 设备</span><br></pre></td></tr></table></figure><p>adb devices 查看已连接的设备信息, 上面已经连接3台设备。</p><h2 id="adb-logcat"><a href="#adb-logcat" class="headerlink" title="adb logcat"></a>adb logcat</h2><p>adb logcat<br>在终端窗口中，按下 Ctrl + C（Windows/Linux）或 Command + C（Mac），这会中断正在运行的命令，包括 adb logcat。</p><h4 id="保存到文件"><a href="#保存到文件" class="headerlink" title="保存到文件"></a>保存到文件</h4><p>adb logcat &gt; logcat.txt<br>将设备的日志输出保存到指定的文件（logcat.txt）。这会将所有的日志信息写入文件。</p><h4 id="过滤保存"><a href="#过滤保存" class="headerlink" title="过滤保存"></a>过滤保存</h4><p>adb logcat -s TAG &gt; logcat.txt<br>过滤保存，只保存特定 TAG 的日志信息。</p><h4 id="限制保存行数"><a href="#限制保存行数" class="headerlink" title="限制保存行数"></a>限制保存行数</h4><p>adb logcat -t 1000 &gt; logcat.txt<br>限制保存的行数，上述例子保存最新的1000行日志。</p><h4 id="指定时间范围"><a href="#指定时间范围" class="headerlink" title="指定时间范围"></a>指定时间范围</h4><p>adb logcat -v time -d -t ‘2023-01-01 00:00:00’ &gt; logcat.txt<br>通过 -t 参数指定保存日志的时间范围，上述例子保存从指定时间到现在的日志。</p><h4 id="保存指定级别的日志"><a href="#保存指定级别的日志" class="headerlink" title="保存指定级别的日志"></a>保存指定级别的日志</h4><p>adb logcat *:E &gt; logcat.txt<br>通过 *:E 过滤保存只包含错误级别的日志。可以使用 *:D（调试）、 *:I（信息）、 *:W（警告）等。</p><blockquote><blockquote><p>请注意，以上命令中的 logcat.txt 是保存日志的文件名，你可以根据需要自定义文件名和保存路径。</p></blockquote></blockquote><p>日志等级，优先级从低到高分为以下几种：</p><p>V——Verbose（最低等级，开发调试中的一些详细信息，仅在开发中使用，不可再发布产品中）</p><p>D——Debug（调试，用于调试的信息，可以在发布产品中关闭，比较常见）</p><p>I——info（信息，一般提示性的信息）</p><p>W——Warning（警告）</p><p>E——Error（错误，已经出现可影响运行的错误，比如应用crash时输出的日志）</p><p>在 E级别中可以搜索这个关键字：fatal exception</p><p>ANR全名Application Not Responding，也就是应用无响应当操作在一段时间内系统无法处理时，系统层面会弹出ANR对话框</p><p>在日志中查询：ANR in</p><p>在查到ANR in 之后 上一行会有</p><h2 id="设备的shell界面"><a href="#设备的shell界面" class="headerlink" title="设备的shell界面"></a>设备的shell界面</h2><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>adb shell<br>多个设备情况下：adb -s &lt;设备序列号&gt; shell</p><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>exit</p><h2 id="adb-wifi连接"><a href="#adb-wifi连接" class="headerlink" title="adb wifi连接"></a>adb wifi连接</h2><p>adb connect <device-ip-address><br>adb disconnect 127.0.0.1:26944</device-ip-address></p><h2 id="adb-模拟按键"><a href="#adb-模拟按键" class="headerlink" title="adb 模拟按键"></a>adb 模拟按键</h2><p>adb 命令代替键盘操作，不同的 keycode 能实现不同的功能<br>adb shell input keyevent</p><p><a href="https://developer.android.com/reference/android/view/KeyEvent">https://developer.android.com/reference/android/view/KeyEvent</a></p><h2 id="截屏-adb-shell-screencap-p-sdcard-sc-png"><a href="#截屏-adb-shell-screencap-p-sdcard-sc-png" class="headerlink" title="截屏 adb shell screencap -p /sdcard/sc.png"></a>截屏 adb shell screencap -p /sdcard/sc.png</h2><p>屏幕截图</p><h2 id="录屏-adb-shell-screenrecord-sdcard-filename-mp4"><a href="#录屏-adb-shell-screenrecord-sdcard-filename-mp4" class="headerlink" title="录屏 adb shell screenrecord /sdcard/filename.mp4"></a>录屏 adb shell screenrecord /sdcard/filename.mp4</h2><p>录制 mp4 格式的视频保存到 /sdcard</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;指令&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;作用</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="adb" scheme="https://leolichenxi.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/08/17/U3D/VertexStreamSplitting/"/>
    <id>https://leolichenxi.github.io/2023/08/17/U3D/VertexStreamSplitting/</id>
    <published>2023-08-17T03:57:38.904Z</published>
    <updated>2023-08-17T03:59:39.272Z</updated>
    
    <content type="html"><![CDATA[<p>关于使用VertexStreamSplitting优化带宽<br>方案介绍<br>Tile-based GPUs create a shader that calculates the normalized device coordinates based on the provided vertex shader to do binning. It is executed first on every vertex in the scene, whether visible or not. Keeping vertex position data contiguous in memory is therefore a big plus. Other places this vertex stream layout can be beneficial is for shadow passes, as usually you only need position data for shadow calculations, as well as depth prepasses, which is a technique usually used for console/desktop rendering; this vertex stream layout can be a win for multiple classes of the rendering engine!<br>Stream Splitting involves setting up the vertex buffer with a contiguous section of vertex position data and another section containing interleaved vertex attributes. Most applications usually set up their buffers fully interleaving all attributes. This visual explains the difference:</p><p>Looking at how the GPU fetches vertex data helps us understand the benefits of stream splitting. Assuming for the sake of argument:<br>●32 byte cache lines (a pretty common size)<br>●Vertex format consisting of:Position, vec3<float32> = 12 bytes<br>○Normal vec3<float32> = 12 bytes<br>○UV coordinates vec2<float32> = 8 bytes<br>○Total size = 32 bytes<br>When the GPU fetches data from memory for binning, it will pull a 32-byte cache line to operate on. Without vertex stream splitting, it will only actually use the first 12 bytes of this cache line for binning, and discard the other 20 bytes as it fetches the next vertex. With vertex stream splitting, the vertex positions will be contiguous in memory, so when that 32-byte chunk is pulled into cache, it will actually contain 2 whole vertex positions to operate on before having to go back to main memory to fetch more, a 2x improvement!<br>Now, if we combine the vertex stream splitting with vertex compression, we will reduce the size of a single vertex position down to 6 bytes, so a single 32-byte cache line pulled from system memory will have 5 whole vertex positions to operate on, a 5x improvement!<br>原文链接    <a href="https://developer.android.com/games/optimize/vertex-data-management#vertex_stream_splitting">https://developer.android.com/games/optimize/vertex-data-management#vertex_stream_splitting</a></float32></float32></float32></p><p>摘要：更改顶点缓存布局，将Position与其他的顶点属性分开处理，使Position属性的内存分布变得连续，从而提高cache命中率，降低带宽与性能开销，配合Vertex Compression 使用，效率会更高</p><p>unity当中实现也比较简单，将顶点属性分配到不同的stream中，unity支持4个stream，我们这边用2个就可以了，在工具导出fbx的mesh时为新生成的mesh设置下即可</p><p>测试数据<br>Device：黑鲨 3Pro   GPU:Adreno (TM) 650<br>测试环境：一定数量的玩家主城白模，顶点数约 45w   FPS：30 </p><p>Bandwidth(Bytes/Second)</p><p>Original Mesh：R + W  ≈  1.75g<br>Vertex Stream Splitting Mesh：R + W  ≈  1.35g<br>带宽降低约400M，主要来自Read带宽</p><p>VertexMemoryRead(Bytes/Second)</p><p>VertexMemoryRead相差约400M， 对比上一条，可见降低的Read带宽均为VertexMemory</p><p>Avg(% Stalled on System Memory)</p><p>可以看到StalledOnSystemMemory的百分比下降明显，原因是cache命中率的提高，大大降低了system memory的读取</p><p>附录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static readonly VertexAttributeDescriptor[] vertexAttributeDescriptorList = new[]&#123;</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3,0),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Normal, VertexAttributeFormat.Float32, 3,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Tangent, VertexAttributeFormat.Float32, 4,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Color, VertexAttributeFormat.Float32, 4,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord1, VertexAttributeFormat.Float32, 2,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord2, VertexAttributeFormat.Float32, 4,1)</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> private static Mesh CreateMeshFrom(Mesh mesh)</span><br><span class="line"> &#123;</span><br><span class="line">     Mesh mesh1 = Object.Instantiate(mesh);</span><br><span class="line">      </span><br><span class="line">     //顶点属性分流</span><br><span class="line"></span><br><span class="line">     //设置顶点属性</span><br><span class="line">     int vertexCount = mesh.vertexCount;</span><br><span class="line">     mesh1.SetVertexBufferParams(vertexCount,vertexAttributeDescriptorList);</span><br><span class="line">     return mesh1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于使用VertexStreamSplitting优化带宽&lt;br&gt;方案介绍&lt;br&gt;Tile-based GPUs create a shader that calculates the normalized device coordinates based on the p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/05/22/U3D/DrawIntstance/DrawInstance%E8%AE%B0%E5%BD%95/"/>
    <id>https://leolichenxi.github.io/2023/05/22/U3D/DrawIntstance/DrawInstance%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-22T02:44:08.466Z</published>
    <updated>2023-05-22T02:44:45.878Z</updated>
    
    <content type="html"><![CDATA[<p>Graphics.DrawMeshInstanced<br>Graphics.DrawMeshInstancedIndirect</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Graphics.DrawMeshInstanced&lt;br&gt;Graphics.DrawMeshInstancedIndirect&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/03/21/U3D/ECS/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2023/03/21/U3D/ECS/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-21T02:33:11.168Z</published>
    <updated>2023-03-27T08:30:12.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="理解篇"><a href="#理解篇" class="headerlink" title="理解篇"></a>理解篇</h2><p>一般游戏的性能指标有:帧率、稳定性、流畅性、加载时间(loading)、内存占用、安装包大小、网络延迟、耗电量等。</p><h2 id="帧率-流畅性"><a href="#帧率-流畅性" class="headerlink" title="帧率-流畅性"></a>帧率-流畅性</h2><p>FPS低：基本每一帧耗时都较长<br>卡顿： 某一帧或几帧耗时较高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h1&gt;&lt;h2 id=&quot;理解篇&quot;&gt;&lt;a href=&quot;#理解篇&quot; class=&quot;headerlink&quot; title=&quot;理解篇&quot;&gt;&lt;/a&gt;理解</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/03/21/U3D/ECS/SLG%E5%A4%A7%E4%B8%96%E7%95%8C%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2023/03/21/U3D/ECS/SLG%E5%A4%A7%E4%B8%96%E7%95%8C%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-21T02:32:40.624Z</published>
    <updated>2023-03-21T06:05:00.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SLG大世界方案"><a href="#SLG大世界方案" class="headerlink" title="SLG大世界方案"></a>SLG大世界方案</h1><p>[toc]</p><h1 id="基本方案选型"><a href="#基本方案选型" class="headerlink" title="基本方案选型"></a>基本方案选型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SLG大世界方案&quot;&gt;&lt;a href=&quot;#SLG大世界方案&quot; class=&quot;headerlink&quot; title=&quot;SLG大世界方案&quot;&gt;&lt;/a&gt;SLG大世界方案&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基本方案选型&quot;&gt;&lt;a href=&quot;#基本方案选型&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%AF%87/"/>
    <id>https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%AF%87/</id>
    <published>2023-01-05T07:33:05.754Z</published>
    <updated>2023-01-05T07:33:07.377Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E7%AF%87-%E5%AE%89%E5%8D%93/"/>
    <id>https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E7%AF%87-%E5%AE%89%E5%8D%93/</id>
    <published>2023-01-05T07:32:49.724Z</published>
    <updated>2023-01-05T08:08:01.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存(Memory)是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p><p>CPU只能访问其寄存器（Register）和内存（Memory）， 无法直接访问硬盘（Disk）。 存储在硬盘上的数据必须首先传输到内存中才能被CPU访问。从访问速度来看，对寄存器的访问非常快，通常为1纳秒； 对内存的访问相对较慢，通常为100纳秒（使用缓存加速的情况下）；而对硬盘驱动器的访问速度最慢，通常为10毫秒。</p><p>当一个程序加载到内存中时，它由四个内存区域组成：</p><p>堆栈（Stack）：存储由该程序的每个函数创建的临时变量<br>堆（Heap）：该区域特别适用于动态内存分配<br>数据（Data）：存储该程序的全局变量和静态变量<br>代码（Code）：存储该程序的指令</p><h2 id="Android之Dalvik"><a href="#Android之Dalvik" class="headerlink" title="Android之Dalvik"></a>Android之Dalvik</h2><p>Dalvik 是 Google 公司自己设计用于 Android 平台的 Java 虚拟机，Android 工程师编写的 Java 或者 Kotlin 代码最终都是在这台虚拟机中被执行的。在 Android 5.0 之前叫作 DVM，5.0 之后改为 ART（Android Runtime）。</p><p>在整个 Android 操作系统体系中，ART 位于以下图中红框位置：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h2&gt;&lt;p&gt;内存(Memory)是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>局部性和缓存命中率</title>
    <link href="https://leolichenxi.github.io/2022/02/01/%E4%BB%A3%E7%A0%81%E7%AF%87/%E5%B1%80%E9%83%A8%E6%80%A7/"/>
    <id>https://leolichenxi.github.io/2022/02/01/%E4%BB%A3%E7%A0%81%E7%AF%87/%E5%B1%80%E9%83%A8%E6%80%A7/</id>
    <published>2022-02-01T05:43:00.000Z</published>
    <updated>2022-02-21T11:12:30.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h2><h2 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;时间局部性&quot;&gt;&lt;a href=&quot;#时间局部性&quot; class=&quot;headerlink&quot; title=&quot;时间局部性&quot;&gt;&lt;/a&gt;时间局部性&lt;/h2&gt;&lt;h2 id=&quot;空间局部性&quot;&gt;&lt;a href=&quot;#空间局部性&quot; class=&quot;headerlink&quot; title=&quot;空间局</summary>
      
    
    
    
    <category term="Codes" scheme="https://leolichenxi.github.io/categories/Codes/"/>
    
    
    <category term="Codes" scheme="https://leolichenxi.github.io/tags/Codes/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2021/11/18/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2021/11/18/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-18T07:20:09.089Z</published>
    <updated>2021-11-18T07:23:24.171Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity DOTS</title>
    <link href="https://leolichenxi.github.io/2021/08/30/U3D/ECS/Unity%20DOTS/"/>
    <id>https://leolichenxi.github.io/2021/08/30/U3D/ECS/Unity%20DOTS/</id>
    <published>2021-08-30T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:38.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><p><a href="file:///D:/Program%20Files/2020.3.14f1c1/Editor/Data/Documentation/en/Manual/JobSystem.html">官方文档</a></p><ol><li><p>借助 Unity C# 作业系统，用户可以编写与 Unity 其余部分良好交互的多线程代码，并使编写正确代码变得更加容易。</p></li><li><p>编写多线程代码可以带来高性能优势，包括显著提高帧率。将 Burst 编译器与 C# 作业配合使用可以提高代码生成质量，还可以大大降低移动设备的电池消耗。</p></li><li><p>C# 作业系统的一个重要特点是它与 Unity 内部使用的系统（Unity 的原生作业系统）相集成。用户编写的代码与 Unity 共享工作线程。此协作避免了创建超过 CPU 核心数的线程（这种情况会导致争用 CPU 资源）</p></li></ol><h3 id="NativeContainer"><a href="#NativeContainer" class="headerlink" title="NativeContainer"></a>NativeContainer</h3><blockquote><p>NativeContainer是一种托管值类型，为本机内存提供了一个相对安全的C#封装器。它包含一个指向非托管分配的指针。与Unity C# 作业系统一起使用时，NativeContainer允许Job 访问与主线程共享的数据，而不是使用副本。</p></blockquote><ul><li>NativeList - 可调整大小的 NativeArray。</li><li>NativeHashMap - 键/值对。</li><li>NativeMultiHashMap - 每个键有多个值。</li><li>NativeQueue  - 先进先出 (FIFO) 队列。</li></ul><h3 id="NativeContainer-Allocator"><a href="#NativeContainer-Allocator" class="headerlink" title="NativeContainer Allocator"></a>NativeContainer Allocator</h3><blockquote><p>创建 NativeContainer 时，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。因此，可以定制分配以便在每种情况下获得最佳性能。可以使用三种 Allocator 类型进行 NativeContainer 内存分配和释放。在实例化 NativeContainer 时需要指定适当的一种类型。</p></blockquote><ul><li>Allocator.Temp 具有最快的分配速度。此类型适用于寿命为一帧或更短的分配，不应该使用Temp将NativeContainer 分配传递给Job，在方法调用返回之前，还需要调用Dispose方法。</li></ul><p>以下错误 不应该使用Temp将NativeContainer 分配传递给Job</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public struct JobSum : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public int b;</span><br><span class="line">    public NativeArray&lt;int&gt; result;</span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] =  result[0]+ a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    void Test()</span><br><span class="line">    &#123;</span><br><span class="line">        JobSum jobSum = new JobSum();</span><br><span class="line">        jobSum.a = 1;</span><br><span class="line">        jobSum.b = 10;</span><br><span class="line">        </span><br><span class="line">        NativeArray&lt;int&gt;  result = new NativeArray&lt;int&gt;(1, Allocator.Temp );</span><br><span class="line">        jobSum.result = result;</span><br><span class="line">        var handle =  jobSum.Schedule();</span><br><span class="line">        handle.Complete();</span><br><span class="line">        result.Dispose();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Allocator.TempJob的分配速度比Temp慢，但比Persistent快。此类型适用于寿命为四帧的分配，并具有线程安全性，如果没有在四帧内对其执行Dispose,控制台会输出一条从本机代码生成的警告。大多数小作业都使用这种 NativeContainer 分配类型。</p></li><li><p>Allocator.Persistent 是最慢的分配，但可以在您所需的任意时间内持续存在，如果有必要，可以在整个应用程序的生命周期内存在。此分配器是直接调用 malloc 的封装器。持续时间较长的作业可以使用这种 NativeContainer 分配类型。在非常注重性能的情况下不应使用 Persistent。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Job-System&quot;&gt;&lt;a href=&quot;#Job-System&quot; class=&quot;headerlink&quot; title=&quot;Job System&quot;&gt;&lt;/a&gt;Job System&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;file:///D:/Program%20Files/20</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="框架" scheme="https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android 常见 Crash</title>
    <link href="https://leolichenxi.github.io/2021/08/30/U3D/ECS/AndroidCrash/"/>
    <id>https://leolichenxi.github.io/2021/08/30/U3D/ECS/AndroidCrash/</id>
    <published>2021-08-30T04:00:00.000Z</published>
    <updated>2023-03-16T03:30:12.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Crash"><a href="#Android-Crash" class="headerlink" title="Android Crash"></a>Android Crash</h1><p><a href="https://developer.android.com/games/optimize/crash?hl=zh-cn">Android官网检测和诊断崩溃问题</a></p><p>Android 6.0的源码剖析<a href="http://gityuan.com/2016/06/24/app-crash/">理解Android Crash处理流程</a></p><p><a href="https://zhuanlan.zhihu.com/p/77984555">unity crash 的快速定位</a></p><p>基本概念：</p><ul><li>ANR </li></ul><p>用户在使用App过程中出现弹框，提示应用无响应，计为一次ANR，ANR仅用于Android平台应用。</p><ul><li>Java Crash</li></ul><p>Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出，Jvm虚拟机退出，系统弹框提醒用户，这个我们可以看log查看报错原因，Crash工具都能捕获到。</p><ul><li>Native Crash</li></ul><p>那 Native 崩溃一般都是因为Native代码中访问非法地址或者是地址对齐出现问题，再或者是发生程序主动abort，这些都会产生对应的signal信号，导致程序异常退出</p><ul><li>SIGSEGV </li></ul><p>一般是由于空指针、非法指针造成</p><ul><li>SIGABRT</li></ul><p>后者主要因为 ANR 和调用abort()退出所导致。</p><h1 id="Crash常见原因"><a href="#Crash常见原因" class="headerlink" title="Crash常见原因"></a>Crash常见原因</h1><ul><li><p>OOM</p><p>代码层或资源内存泄漏</p><ol><li>java.lang.outofmemory</li><li>GL_OUT_OF_MEMORY </li><li>vukan out of memory</li></ol></li><li><p>NullPointerException </p><p>空指针异常</p></li><li><p>IndexOutOfBoundsException</p><p>数组、集合等越界</p></li><li><p>java.lang.StackOverflowError </p><p>堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误，（死循环了等）</p></li><li><p>ClassCastException </p><p>类型转换异常 </p></li><li><p>ActivityNotFoundException </p><p>Activity未找到异常</p></li><li><p>SecurityException </p><p>安全异常 </p></li><li><p>llegalArgumentException: Service not registered </p><p>服务未注册异常 </p></li><li><p>BadTokenException</p></li><li><p>API 平台兼容性<br>Unity 的一些API在不同硬件的兼容性问题</p></li></ul><h2 id="错误符号"><a href="#错误符号" class="headerlink" title="错误符号"></a>错误符号</h2><ol><li><p>SIGSEGV 段错误</p><p>SEGV_MAPERR    要访问的地址没有映射到内存空间。 比如上面对空指针的写操作， 当指针被意外复写为一个较小的数值时。</p><p>SEGV_ACCERR    访问的地址没有权限。比如试图对代码段进行写操作。</p></li><li><p>SIGFPE 浮点错误，一般发生在算术运行出错时。</p><p>FPE_INTDIV    除以0</p><p>FPE_INTOVE    整数溢出</p></li><li><p>SIGBUS 总线错误<br>BUS_ADRALN    地址对齐出错。arm cpu比x86 cpu 要求更严格的对齐机制，所以在 arm cpu 机器中比较常见。</p></li><li><p>SIGILL 发生这种错误一般是由于某处内存被意外改写了。</p><p>ILL_ILLOPC    非法的指令操作码</p><p>ILL_ILLOPN    非法的指令操作数</p></li><li><p>当调用堆栈中出现 stack_chk_fail 函数时，一般是由于比如 strcpy 之类的函数调用将栈上的内容覆盖，而引起栈检查失败。</p></li></ol><p><img src="/images/crash/Signum.jpeg" alt="枚举"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><p>一般分为Java Crash 和 Native Crash</p></blockquote><h2 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>出错时界面不会弹出提示框提醒程序崩溃（Android 5.0以下）</li><li>出错时会弹出提示框提醒程序崩溃（Android 5.0以上）</li><li>程序会直接闪退到系统桌面</li><li>这类错误一般是由C++层代码错误引起的</li><li>绝大部分Crash工具不能够捕获</li></ol><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><h1 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h1><ol><li>堆栈信息查找</li><li>log日志，尤其是warning error相关;</li><li>机型信息  GPU 内存 系统 厂商 信息等共性信息，(有可能某个厂商特定修改);</li><li>复现步骤;</li><li>前后台信息;</li><li>图形API vukan opengl 版本的bug.</li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>addr2line，objdump，ndk-stack等几个工具</p><h1 id="crash上报第三方"><a href="#crash上报第三方" class="headerlink" title="crash上报第三方"></a>crash上报第三方</h1><p>CrashSight Bugly Firebase</p><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-Crash&quot;&gt;&lt;a href=&quot;#Android-Crash&quot; class=&quot;headerlink&quot; title=&quot;Android Crash&quot;&gt;&lt;/a&gt;Android Crash&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="其它" scheme="https://leolichenxi.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>CSharpLua</title>
    <link href="https://leolichenxi.github.io/2021/06/17/Tools/CSharp.lua/"/>
    <id>https://leolichenxi.github.io/2021/06/17/Tools/CSharp.lua/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2021-06-17T11:12:00.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSharpLua"><a href="#CSharpLua" class="headerlink" title="CSharpLua"></a>CSharpLua</h1><p>一个翻译c#为Lua的工具<br>Git地址<a href="https://github.com/yanghuan/CSharp.lua.git">Charp.lua</a></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D:\&gt;dotnet CSharp.Lua.Launcher.dll -h</span><br><span class="line">Usage: CSharp.lua [-s srcfolder] [-d dstfolder]</span><br><span class="line">Arguments</span><br><span class="line">-s              : can be a directory where all cs files will be compiled, or a list of files, using &#x27;;&#x27; or &#x27;,&#x27; to separate</span><br><span class="line">-d              : destination directory, will put the out lua files</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">-h              : show the help message and exit</span><br><span class="line">-l              : libraries referenced, use &#x27;;&#x27; to separate</span><br><span class="line">                  if the librarie is a module, whitch is compield by CSharp.lua with -module arguemnt, the last character needs to be &#x27;!&#x27; in order to mark  </span><br><span class="line"></span><br><span class="line">-m              : meta files, like System.xml, use &#x27;;&#x27; to separate</span><br><span class="line">-csc            : csc.exe command argumnets, use &#x27; &#x27; or &#x27;\t&#x27; to separate</span><br><span class="line"></span><br><span class="line">-c              : support classic lua version(5.1), default support 5.3</span><br><span class="line">-a              : attributes need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-a&quot;&quot; only, all attributes whill be exported</span><br><span class="line">-e              : enums need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-e&quot;&quot; only, all enums will be exported</span><br><span class="line">-ei             : enums is represented by a variable reference rather than a constant value, need to be used with -e</span><br><span class="line">-p              : do not use debug.setmetatable, in some Addon/Plugin environment debug object cannot be used</span><br><span class="line">-metadata       : export all metadata, use @CSharpLua.Metadata annotations for precise control</span><br><span class="line">-module         : the currently compiled assembly needs to be referenced, it&#x27;s useful for multiple module compiled</span><br><span class="line">-inline-property: inline some single-line properties</span><br><span class="line">-include        : the root directory of the CoreSystem library, adds all the dependencies to a single file named out.lua</span><br><span class="line">-noconcurrent   : close concurrent compile</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><p>打开 CSharp.lua.sln<br>自己可编译 我这里选择 Release Build</p><p><img src="/images/csharplua/2.png" alt="截图"></p><p>红色标记处为编译成功后</p><p>这里新建一个文件夹将上图红色标记文件拷出</p><p><img src="/images/csharplua/3.png" alt="截图"></p><p>cmd测试： dotnet CSharp.lua.Launcher.dll -h</p><p><img src="/images/csharplua/1.png" alt="截图"></p><h3 id="编译c-工程"><a href="#编译c-工程" class="headerlink" title="编译c# 工程"></a>编译c# 工程</h3><p>lua 使用的 5.3 版本</p><p>新建 CompileScript Console工程,新增文件夹Core<br>创建测试脚本 </p><p>Test.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    public class Test</span><br><span class="line">    &#123;</span><br><span class="line">        public int a;</span><br><span class="line">        public int b;</span><br><span class="line"></span><br><span class="line">        public Test()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(a + b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TestClass2.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    class TestClass2</span><br><span class="line">    &#123;</span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">            Test t = new Test();</span><br><span class="line">            t.Debug();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>命令行： dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export</p></blockquote><p>在Export 下创建lua工程<br>将<img src="/images/csharplua/4.png" alt="截图"> copy 到工程，新建main.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;All&quot;)()</span><br><span class="line">require(&quot;manifest&quot;)()</span><br><span class="line"></span><br><span class="line">local baseTime = System.DateTime(1970, 1, 1)</span><br><span class="line">print(baseTime:ToString())</span><br><span class="line"></span><br><span class="line">local t = CompileScript.Core.Test()</span><br><span class="line">t.a = 10</span><br><span class="line">t:Debug()</span><br></pre></td></tr></table></figure><p>运行 可以</p><p>将<img src="/images/csharplua/5.png" alt="截图"> copy 到工程，新建main.lua</p><h3 id="第三方库引用"><a href="#第三方库引用" class="headerlink" title="第三方库引用"></a>第三方库引用</h3><p>CompileScript 工程添加Newtonsoft库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Newtonsoft.Json;</span><br><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    public class Test</span><br><span class="line">    &#123;</span><br><span class="line">        public int a;</span><br><span class="line">        public int b;</span><br><span class="line"></span><br><span class="line">        public Test()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">            Console.WriteLine(a + b);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(JsonConvert.SerializeObject(this));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译指令</p><blockquote><p>G:\Learning\CsharpLua\CSharpLuaTools&gt;dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export -l ../3rd/Newtonsoft.Json.dll</p></blockquote><p>运行代码 报错</p><p><img src="/images/csharplua/6.png" alt="截图"></p><blockquote><p>这里第三方库dll的实现需要自己适配</p></blockquote><p>这里适配 NewtonsoftJson.JsonConvert.SerializeObject(this)</p><p>新建 NewtonsoftJson.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Newtonsoft = &#123;&#125;</span><br><span class="line">Newtonsoft.Json = &#123;&#125;</span><br><span class="line">Newtonsoft.Json.JsonConvert = &#123;&#125;</span><br><span class="line">Newtonsoft.Json.JsonConvert.SerializeObject = function (obj)</span><br><span class="line">     return &quot;todo&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return Newtonsoft</span><br></pre></td></tr></table></figure><p>return “todo”可修改为lua相关的json库，比如cjson</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>第三方库的依赖尽量少依赖</li><li>如果有需要查看适配结果，多测试</li><li>核心库CoreSystem.Lua 文件夹下的适配了多数System。</li></ul><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>如果手写Lua 需要调用翻译的lua class 时，如果不知道如何new对象等，参考TestClass2, 创建一个专门的class 用来测试 翻译出的如何new 对象。</p><h3 id="适配踩坑"><a href="#适配踩坑" class="headerlink" title="适配踩坑"></a>适配踩坑</h3><p>Unity工程适配 ToLua支持，Xlua 实际测试不支持，如果在Xlua 使用，不得依赖UnityEngine 相关库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSharpLua&quot;&gt;&lt;a href=&quot;#CSharpLua&quot; class=&quot;headerlink&quot; title=&quot;CSharpLua&quot;&gt;&lt;/a&gt;CSharpLua&lt;/h1&gt;&lt;p&gt;一个翻译c#为Lua的工具&lt;br&gt;Git地址&lt;a href=&quot;https://git</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="Charp Lua" scheme="https://leolichenxi.github.io/tags/Charp-Lua/"/>
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="https://leolichenxi.github.io/2021/06/17/Tools/Cmake/"/>
    <id>https://leolichenxi.github.io/2021/06/17/Tools/Cmake/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2023-06-13T02:38:55.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMAKE-使用"><a href="#CMAKE-使用" class="headerlink" title="CMAKE 使用"></a>CMAKE 使用</h1><p>考虑到在项目中定义Native库和编译其它的开源Native库，客户端往往对编译原理计算机基础比较薄弱，记录下CMake使用笔记</p><p>主要从官网记录</p><p><a href="https://cmake.org/">CMake官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMAKE-使用&quot;&gt;&lt;a href=&quot;#CMAKE-使用&quot; class=&quot;headerlink&quot; title=&quot;CMAKE 使用&quot;&gt;&lt;/a&gt;CMAKE 使用&lt;/h1&gt;&lt;p&gt;考虑到在项目中定义Native库和编译其它的开源Native库，客户端往往对编译原理计算机基</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="CMake" scheme="https://leolichenxi.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>四叉树</title>
    <link href="https://leolichenxi.github.io/2021/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91/"/>
    <id>https://leolichenxi.github.io/2021/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-06-14T05:37:26.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h1><p><a href="https://zh.wikipedia.org/wiki%E5%9B%9B%E5%8F%89%E6%A0%91">四叉树Wiki</a></p><blockquote><p>四叉树是一种树状数据结构，在每一个节点上会有四个子区块。四叉树常应用于二维空间资料的分析与分类。 它将资料区分成为四个象限。资料范围可以是方形或矩形或其他任意形状。这种数据结构是由 拉斐尔·芬科尔(Raphael Finkel) 与 J. L. Bentley 在1974年发展出来 。 类似的资料分割方法也称为 Q-tree。 所有的四叉树法有共同之特点:</p></blockquote><ol><li>可分解成为各自的区块</li><li>每个区块都有节点容量。当节点达到最大容量时，节点分裂</li><li>树状数据结构依造四叉树法加以区分</li></ol><h1 id="根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下"><a href="#根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下" class="headerlink" title="根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下"></a>根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下</h1><h2 id="只要点在区域内就可以插入"><a href="#只要点在区域内就可以插入" class="headerlink" title="只要点在区域内就可以插入"></a>只要点在区域内就可以插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public class TreeRect</span><br><span class="line">&#123;</span><br><span class="line">    public float X &#123; get; private set; &#125;</span><br><span class="line">    public float Y &#123; get; private set; &#125;</span><br><span class="line">    public float W &#123; get; private set; &#125;</span><br><span class="line">    public float H &#123; get; private set; &#125;</span><br><span class="line">    public float HalfW &#123; get; private set; &#125;</span><br><span class="line">    public float HalfH &#123; get; private set; &#125;</span><br><span class="line">    public float XL &#123; get; private set; &#125;</span><br><span class="line">    public float XR&#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public float YT &#123; get; private set; &#125;</span><br><span class="line">    public float YB &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public TreeRect(float x, float y)</span><br><span class="line">    &#123;</span><br><span class="line">        SetRect(x, y, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 四边形</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;w&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;h&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public TreeRect(float x, float y, float w, float h)</span><br><span class="line">    &#123;</span><br><span class="line">        SetRect(x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void SetRect(float x, float y, float w, float h)</span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line"></span><br><span class="line">        HalfW = W * 0.5f;</span><br><span class="line">        HalfH = H * 0.5f;</span><br><span class="line"></span><br><span class="line">        XL = X - HalfW;</span><br><span class="line">        XR = X + HalfW;</span><br><span class="line">        YB = Y - HalfH;</span><br><span class="line">        YT = Y + HalfH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return (!(XR &lt; other.XL || XL &gt; other.XR)) &amp;&amp; (!(YT &lt; other.YB || YB &gt; other.YT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsCenterIn(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return other.X &lt;= XR &amp;&amp; other.X &gt;= XL &amp;&amp; other.Y &lt;= YT &amp;&amp; other.Y &gt;= YB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsIn(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return XR &lt;= other.XR  &amp;&amp; XL &gt;= other.XL &amp;&amp; YT &lt;= other.YT &amp;&amp; YB &gt;= other.YB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;(&#123;X&#125;,&#123;Y&#125;,&#123;W&#125;,&#123;H&#125;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static TreeRect operator *(TreeRect rhs,float lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.SetRect(rhs.X * lhs, rhs.Y * lhs, rhs.W * lhs,  rhs.H * lhs);</span><br><span class="line">        return rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TreeObject</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 信息</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public TreeRect TreeRect;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 属于哪个节点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public MapQuadTree Node ;</span><br><span class="line">    public int Id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapQuadTree</span><br><span class="line">&#123;</span><br><span class="line">    public MapQuadTree Root &#123; get; &#125; //根节点</span><br><span class="line">    public int MaxCount &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int MaxDeep &#123; get; private set; &#125; = 4;</span><br><span class="line">    public int TreeDeep &#123; get; &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;MapQuadTree&gt; Childs &#123; get; private set; &#125; </span><br><span class="line">    public MapQuadTree Parent &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public readonly List&lt;TreeObject&gt; TreePointObjs = new List&lt;TreeObject&gt;();</span><br><span class="line"></span><br><span class="line">    // public readonly List&lt;TreeObject&gt; BoundTreeObjs = new List&lt;TreeObject&gt;();</span><br><span class="line">    public TreeRect Rect &#123; get; &#125;</span><br><span class="line">    public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0;</span><br><span class="line">    public bool IsEmptyLeafNode =&gt; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode ;</span><br><span class="line"></span><br><span class="line">    public MapQuadTree(TreeRect rect)</span><br><span class="line">    &#123;</span><br><span class="line">        Rect = rect;</span><br><span class="line">        TreeDeep = 0;</span><br><span class="line">        Root = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MapQuadTree(TreeRect rect, int treeDeep, MapQuadTree parent) : this(rect)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeDeep = treeDeep + 1;</span><br><span class="line">        this.Parent = parent;</span><br><span class="line">        Root = parent.Root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Insert(TreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!IsInTreeRect(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeObj.Node = this;</span><br><span class="line">        if (Childs == null)</span><br><span class="line">        &#123;</span><br><span class="line">            TreePointObjs.Add(treeObj);</span><br><span class="line">            if (TreePointObjs.Count &gt; MaxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                SliceTree();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[i].Insert(treeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SliceTree()</span><br><span class="line">    &#123;</span><br><span class="line">        if (TreeDeep &gt;= MaxDeep)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 四分 可根据情况 调整</span><br><span class="line">        // lb, lt, rt, rb  目前与unity recttranform 的 4个 corner 保持一致的分布顺序</span><br><span class="line">        Childs = new List&lt;MapQuadTree&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; TreePointObjs.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; Childs.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[j].Insert(TreePointObjs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreePointObjs.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.Intersect(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsInTreeRect(TreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.IsCenterIn(treeObj.TreeRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ClearEmptyNode()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;MapQuadTree&gt; emptyLeafNodes = new List&lt;MapQuadTree&gt;();</span><br><span class="line">        ForEachEmptyLeafNode(Root, (t) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            emptyLeafNodes.Add(t);</span><br><span class="line">        &#125;);</span><br><span class="line">        while (emptyLeafNodes.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; emptyLeafNodes.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            emptyLeafNodes.Clear();</span><br><span class="line">            ForEachEmptyLeafNode(Root, (t) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes.Add(t);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachEmptyLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsEmptyLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachEmptyLeafNode(node.Childs[i],treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void ForEachLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachLeafNode(node.Childs[i],treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void RemoveChildNode(MapQuadTree node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Childs!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            Childs.Remove(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void ForEach(Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEach(Root, each);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;TreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;TreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var treeObject in node.TreePointObjs)</span><br><span class="line">            &#123;</span><br><span class="line">                treeAction?.Invoke(treeObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEach(MapQuadTree node, Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForEachNodeValues(node, each);</span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachNodeValues(node.Childs[i], each);</span><br><span class="line">                ForEach(node.Childs[i], each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachNodeValues(MapQuadTree node, Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        each?.Invoke(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只要点和边框必须在区域内就可以插入"><a href="#只要点和边框必须在区域内就可以插入" class="headerlink" title="只要点和边框必须在区域内就可以插入"></a>只要点和边框必须在区域内就可以插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BoundTreeObject</span><br><span class="line">&#123;</span><br><span class="line">    public TreeRect TreeRect;</span><br><span class="line">    public MapQuadBoundTree Node;</span><br><span class="line">    public int Id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapQuadBoundTree</span><br><span class="line">&#123;</span><br><span class="line">    public MapQuadBoundTree Root &#123; get; &#125; //根节点</span><br><span class="line">    public int MaxCount &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int MaxDeep &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int TreeDeep &#123; get; &#125;</span><br><span class="line">    public List&lt;MapQuadBoundTree&gt; Childs &#123; get; private set; &#125;</span><br><span class="line">    public MapQuadBoundTree Parent &#123; get; &#125;</span><br><span class="line">    private TreeRect[] _treeChildRects = new TreeRect[4];</span><br><span class="line">    public readonly List&lt;BoundTreeObject&gt; TreePointObjs = new List&lt;BoundTreeObject&gt;();</span><br><span class="line"></span><br><span class="line">    public readonly List&lt;BoundTreeObject&gt; BoundTreeObjs = new List&lt;BoundTreeObject&gt;();</span><br><span class="line">    public TreeRect Rect &#123; get; &#125;</span><br><span class="line">    public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0;</span><br><span class="line">    public bool IsEmptyLeafNode =&gt; BoundTreeObjs.Count == 0 &amp;&amp; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode;</span><br><span class="line"></span><br><span class="line">    public MapQuadBoundTree(TreeRect rect)</span><br><span class="line">    &#123;</span><br><span class="line">        Rect = rect;</span><br><span class="line">        TreeDeep = 0;</span><br><span class="line">        Root = this;</span><br><span class="line">        _treeChildRects[0] =</span><br><span class="line">            new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[1] =</span><br><span class="line">            new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[2] =</span><br><span class="line">            new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[3] =</span><br><span class="line">            new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MapQuadBoundTree(TreeRect rect, int treeDeep, MapQuadBoundTree parent) : this(rect)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeDeep = treeDeep + 1;</span><br><span class="line">        this.Parent = parent;</span><br><span class="line">        Root = parent.Root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Insert(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!IsInTreeRect(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeObj.Node = this;</span><br><span class="line">        if (IsAllInsert(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            BoundTreeObjs.Add(treeObj);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Childs == null)</span><br><span class="line">        &#123;</span><br><span class="line">            TreePointObjs.Add(treeObj);</span><br><span class="line">            if (TreePointObjs.Count &gt; MaxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                SliceTree();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[i].Insert(treeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsAllInsert(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; _treeChildRects.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_treeChildRects[i].Intersect(treeObj.TreeRect))</span><br><span class="line">            &#123;</span><br><span class="line">                if (count &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SliceTree()</span><br><span class="line">    &#123;</span><br><span class="line">        if (TreeDeep &gt;= MaxDeep)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // lb, lt, rt, rb  目前与unity recttranform 的 4个 corner 保持一致的分布顺序</span><br><span class="line">        Childs = new List&lt;MapQuadBoundTree&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; TreePointObjs.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; Childs.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[j].Insert(TreePointObjs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreePointObjs.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.Intersect(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsInTreeRect(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.IsCenterIn(treeObj.TreeRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ClearEmptyNode()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO  清除空节点 只需从叶节点删除</span><br><span class="line">        List&lt;MapQuadBoundTree&gt; emptyLeafNodes = new List&lt;MapQuadBoundTree&gt;();</span><br><span class="line">        ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;);</span><br><span class="line">        while (emptyLeafNodes.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; emptyLeafNodes.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            emptyLeafNodes.Clear();</span><br><span class="line">            ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachEmptyLeafNode(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsEmptyLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachEmptyLeafNode(node.Childs[i], treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void RemoveChildNode(MapQuadBoundTree node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Childs.Remove(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void ForEach(Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEach(Root, each);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreach (var boundTreeObj in node.BoundTreeObjs)</span><br><span class="line">        &#123;</span><br><span class="line">            if (boundTreeObj.TreeRect.Intersect(rect))</span><br><span class="line">            &#123;</span><br><span class="line">                treeAction?.Invoke(boundTreeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var boundTreeObj in node.TreePointObjs)</span><br><span class="line">            &#123;</span><br><span class="line">                if (boundTreeObj.TreeRect.Intersect(rect))</span><br><span class="line">                &#123;</span><br><span class="line">                    treeAction?.Invoke(boundTreeObj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEach(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForEachNodeValues(node, each);</span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachNodeValues(node.Childs[i], each);</span><br><span class="line">                ForEach(node.Childs[i], each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachNodeValues(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        each?.Invoke(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四叉树&quot;&gt;&lt;a href=&quot;#四叉树&quot; class=&quot;headerlink&quot; title=&quot;四叉树&quot;&gt;&lt;/a&gt;四叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki%E5%9B%9B%E5%8F%89%E6%A0%91&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leolichenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://leolichenxi.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GoogleProtobuffer</title>
    <link href="https://leolichenxi.github.io/2021/06/14/Tools/GoogleProtobuffer/"/>
    <id>https://leolichenxi.github.io/2021/06/14/Tools/GoogleProtobuffer/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-06-16T08:51:50.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protocolbuffers"><a href="#Protocolbuffers" class="headerlink" title="Protocolbuffers"></a>Protocolbuffers</h1><ul><li><a href="https://github.com/protocolbuffers/protobuf">官方git地址</a></li><li><a href="https://developers.google.com/protocol-buffers">官方文档地址</a></li><li><a href="https://github.com/protocolbuffers/protobuf/releases">官方Release</a></li><li><a href="https://zhuanlan.zhihu.com/p/38200420">知乎介绍</a></li></ul><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>常见的数据格式：XML,Json,Protobuf,FlatBuffers 等其它。</p><ul><li>数据储存</li><li>数据交换格式</li></ul><p>使用流程：</p><p>1.编写Scheme;<br>2.使用Protoc 生成代码；</p><h2 id="下载Release-Protoc代码生成工具"><a href="#下载Release-Protoc代码生成工具" class="headerlink" title="下载Release Protoc代码生成工具"></a>下载Release Protoc代码生成工具</h2><blockquote><p>Release中下载Window 或 Mac Os<br><img src="/images/protobuffer/1.png" alt="截图"></p></blockquote><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>在下载程序后，需要将下载 zip 文件中的 bin 目录设置到环境变量中。</p><p>然后运行 protoc –version 来确定你的编译运行版本已经被正确配置。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://developers.google.com/protocol-buffers">官方文档地址</a></p><p>生成代码命令</p><blockquote><p>eg:   protoc – csharp_out=SciptOutFolder/  ProtoFolder/filename.proto</p></blockquote><h3 id="Protocol-Buffer-编码原理"><a href="#Protocol-Buffer-编码原理" class="headerlink" title="Protocol Buffer 编码原理"></a>Protocol Buffer 编码原理</h3><p>采用Varint编码规则</p><h4 id="Varint编码"><a href="#Varint编码" class="headerlink" title="Varint编码"></a>Varint编码</h4><p>variant是可变长的编码方式,Varint是一种使用一个或多个字节序列化整数的方法，会把整数编码变为长字节，对于32位整型进过Variant编码后需要1-5个字节,小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用1~10个字节。在实际场景中小数字的使用率远远大于大数字，因此Varint编码对于大部分的场景都可以起到很好的压缩效果。</p><h5 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h5><p>除了最后一个字节外,Varint编码中的每个字节都设置了最高有效位（most significant bit - msb）–msb为1则表明后面的字节还是属于当前数据的,如果是0那么这是当前数据的最后一个字节数据。每个字节的第7位用于以7位为一组存储数字的二进制补码表示，最低有效组在前，或者叫最低有效字节在前。这表明varint编码后数据的字节是按照小端序排列的。</p><p>关于字节排列的方式引用一下维基百科上的词条</p><blockquote><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p></blockquote><p>通俗一点说就是：大端序是按照数字的书写顺序排列的，而小端序是颠倒书写顺序进行排列的。</p><blockquote><p>variant编码对负数编码效率低</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Protocolbuffers&quot;&gt;&lt;a href=&quot;#Protocolbuffers&quot; class=&quot;headerlink&quot; title=&quot;Protocolbuffers&quot;&gt;&lt;/a&gt;Protocolbuffers&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="GoogleProtobuffer" scheme="https://leolichenxi.github.io/tags/GoogleProtobuffer/"/>
    
  </entry>
  
  <entry>
    <title>ECS架构</title>
    <link href="https://leolichenxi.github.io/2021/06/14/U3D/ECS/ECS%E6%9E%B6%E6%9E%84/"/>
    <id>https://leolichenxi.github.io/2021/06/14/U3D/ECS/ECS%E6%9E%B6%E6%9E%84/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:33.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ECS ,即  Entity-Component-System 的缩写，其模式遵循组合优于继承原则，游戏内的每一个单位都是一个实体，每个实体又又一个或多个组件构成，每个组件仅仅包含代表其特性的数据(即在组件中没有任何方法),系统便是来处理拥有一个或多个相同组件的实体集合的工具，其只拥有行为，在这个例子中，处理移动的系统仅仅关心拥有移动能力的实体，它会遍历所有拥有相关组件的实体，并根据相关的数据，更新实体。</p></blockquote><p><img src="/images/ecs/1.png" alt="截图"></p><p>这里核心思路区别于Unity ECS，提供一个设计思路。Unity 后面单独研究下</p><p>ECS 获取组件较为麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ECS ,即  Entity-Component-System 的缩写，其模式遵循组合优于继承原则，游戏内的每一个单位都是一个实体，每个实体又又一个或多个组件构成，每个组件仅仅包含代表其特性的数据(即在组件中没有任何方法),系统便是来处理拥有一个或</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="框架" scheme="https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>开发流程-客户端-策划配置数据</title>
    <link href="https://leolichenxi.github.io/2021/06/14/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AD%96%E5%88%92%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://leolichenxi.github.io/2021/06/14/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AD%96%E5%88%92%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-08-11T09:36:14.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端配置数据管理"><a href="#客户端配置数据管理" class="headerlink" title="客户端配置数据管理"></a>客户端配置数据管理</h1><blockquote><p>开发或上线后不可避免的出现配置逻辑错误问题，系统功能通常会给策划留有很大的配置空间用于铺量和修改，但不可避免的会有错误，这里记录下配置表检查的原则</p></blockquote><h3 id="必须检查的情况"><a href="#必须检查的情况" class="headerlink" title="必须检查的情况"></a>必须检查的情况</h3><ol><li>id 与其它表格关联</li><li>配置资源路径，必须判断资源是否存在</li><li>配置要求一定得格式，比如约定的分隔符 1;2 分割数组，可能会配置成1,2</li><li>有 type:id  type 不同id 指向不用配置表，必须检查。</li><li>未完待续…..</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;客户端配置数据管理&quot;&gt;&lt;a href=&quot;#客户端配置数据管理&quot; class=&quot;headerlink&quot; title=&quot;客户端配置数据管理&quot;&gt;&lt;/a&gt;客户端配置数据管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;开发或上线后不可避免的出现配置逻辑错误问题，系统功能通常会</summary>
      
    
    
    
    <category term="开发流程" scheme="https://leolichenxi.github.io/categories/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
    <category term="开发流程" scheme="https://leolichenxi.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
</feed>
