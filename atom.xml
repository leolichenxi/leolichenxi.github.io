<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CXGame</title>
  
  
  <link href="https://leolichenxi.github.io/atom.xml" rel="self"/>
  
  <link href="https://leolichenxi.github.io/"/>
  <updated>2023-08-17T03:59:39.272Z</updated>
  <id>https://leolichenxi.github.io/</id>
  
  <author>
    <name>李晨曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/08/17/U3D/VertexStreamSplitting/"/>
    <id>https://leolichenxi.github.io/2023/08/17/U3D/VertexStreamSplitting/</id>
    <published>2023-08-17T03:57:38.904Z</published>
    <updated>2023-08-17T03:59:39.272Z</updated>
    
    <content type="html"><![CDATA[<p>关于使用VertexStreamSplitting优化带宽<br>方案介绍<br>Tile-based GPUs create a shader that calculates the normalized device coordinates based on the provided vertex shader to do binning. It is executed first on every vertex in the scene, whether visible or not. Keeping vertex position data contiguous in memory is therefore a big plus. Other places this vertex stream layout can be beneficial is for shadow passes, as usually you only need position data for shadow calculations, as well as depth prepasses, which is a technique usually used for console/desktop rendering; this vertex stream layout can be a win for multiple classes of the rendering engine!<br>Stream Splitting involves setting up the vertex buffer with a contiguous section of vertex position data and another section containing interleaved vertex attributes. Most applications usually set up their buffers fully interleaving all attributes. This visual explains the difference:</p><p>Looking at how the GPU fetches vertex data helps us understand the benefits of stream splitting. Assuming for the sake of argument:<br>●32 byte cache lines (a pretty common size)<br>●Vertex format consisting of:Position, vec3<float32> = 12 bytes<br>○Normal vec3<float32> = 12 bytes<br>○UV coordinates vec2<float32> = 8 bytes<br>○Total size = 32 bytes<br>When the GPU fetches data from memory for binning, it will pull a 32-byte cache line to operate on. Without vertex stream splitting, it will only actually use the first 12 bytes of this cache line for binning, and discard the other 20 bytes as it fetches the next vertex. With vertex stream splitting, the vertex positions will be contiguous in memory, so when that 32-byte chunk is pulled into cache, it will actually contain 2 whole vertex positions to operate on before having to go back to main memory to fetch more, a 2x improvement!<br>Now, if we combine the vertex stream splitting with vertex compression, we will reduce the size of a single vertex position down to 6 bytes, so a single 32-byte cache line pulled from system memory will have 5 whole vertex positions to operate on, a 5x improvement!<br>原文链接    <a href="https://developer.android.com/games/optimize/vertex-data-management#vertex_stream_splitting">https://developer.android.com/games/optimize/vertex-data-management#vertex_stream_splitting</a></float32></float32></float32></p><p>摘要：更改顶点缓存布局，将Position与其他的顶点属性分开处理，使Position属性的内存分布变得连续，从而提高cache命中率，降低带宽与性能开销，配合Vertex Compression 使用，效率会更高</p><p>unity当中实现也比较简单，将顶点属性分配到不同的stream中，unity支持4个stream，我们这边用2个就可以了，在工具导出fbx的mesh时为新生成的mesh设置下即可</p><p>测试数据<br>Device：黑鲨 3Pro   GPU:Adreno (TM) 650<br>测试环境：一定数量的玩家主城白模，顶点数约 45w   FPS：30 </p><p>Bandwidth(Bytes/Second)</p><p>Original Mesh：R + W  ≈  1.75g<br>Vertex Stream Splitting Mesh：R + W  ≈  1.35g<br>带宽降低约400M，主要来自Read带宽</p><p>VertexMemoryRead(Bytes/Second)</p><p>VertexMemoryRead相差约400M， 对比上一条，可见降低的Read带宽均为VertexMemory</p><p>Avg(% Stalled on System Memory)</p><p>可以看到StalledOnSystemMemory的百分比下降明显，原因是cache命中率的提高，大大降低了system memory的读取</p><p>附录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static readonly VertexAttributeDescriptor[] vertexAttributeDescriptorList = new[]&#123;</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3,0),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Normal, VertexAttributeFormat.Float32, 3,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Tangent, VertexAttributeFormat.Float32, 4,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.Color, VertexAttributeFormat.Float32, 4,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord1, VertexAttributeFormat.Float32, 2,1),</span><br><span class="line">     new VertexAttributeDescriptor(VertexAttribute.TexCoord2, VertexAttributeFormat.Float32, 4,1)</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> private static Mesh CreateMeshFrom(Mesh mesh)</span><br><span class="line"> &#123;</span><br><span class="line">     Mesh mesh1 = Object.Instantiate(mesh);</span><br><span class="line">      </span><br><span class="line">     //顶点属性分流</span><br><span class="line"></span><br><span class="line">     //设置顶点属性</span><br><span class="line">     int vertexCount = mesh.vertexCount;</span><br><span class="line">     mesh1.SetVertexBufferParams(vertexCount,vertexAttributeDescriptorList);</span><br><span class="line">     return mesh1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于使用VertexStreamSplitting优化带宽&lt;br&gt;方案介绍&lt;br&gt;Tile-based GPUs create a shader that calculates the normalized device coordinates based on the p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/05/22/U3D/DrawIntstance/DrawInstance%E8%AE%B0%E5%BD%95/"/>
    <id>https://leolichenxi.github.io/2023/05/22/U3D/DrawIntstance/DrawInstance%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-22T02:44:08.466Z</published>
    <updated>2023-05-22T02:44:45.878Z</updated>
    
    <content type="html"><![CDATA[<p>Graphics.DrawMeshInstanced<br>Graphics.DrawMeshInstancedIndirect</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Graphics.DrawMeshInstanced&lt;br&gt;Graphics.DrawMeshInstancedIndirect&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/03/21/U3D/ECS/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2023/03/21/U3D/ECS/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-21T02:33:11.168Z</published>
    <updated>2023-03-27T08:30:12.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="理解篇"><a href="#理解篇" class="headerlink" title="理解篇"></a>理解篇</h2><p>一般游戏的性能指标有:帧率、稳定性、流畅性、加载时间(loading)、内存占用、安装包大小、网络延迟、耗电量等。</p><h2 id="帧率-流畅性"><a href="#帧率-流畅性" class="headerlink" title="帧率-流畅性"></a>帧率-流畅性</h2><p>FPS低：基本每一帧耗时都较长<br>卡顿： 某一帧或几帧耗时较高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h1&gt;&lt;h2 id=&quot;理解篇&quot;&gt;&lt;a href=&quot;#理解篇&quot; class=&quot;headerlink&quot; title=&quot;理解篇&quot;&gt;&lt;/a&gt;理解</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/03/21/U3D/ECS/SLG%E5%A4%A7%E4%B8%96%E7%95%8C%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2023/03/21/U3D/ECS/SLG%E5%A4%A7%E4%B8%96%E7%95%8C%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-21T02:32:40.624Z</published>
    <updated>2023-03-21T06:05:00.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SLG大世界方案"><a href="#SLG大世界方案" class="headerlink" title="SLG大世界方案"></a>SLG大世界方案</h1><p>[toc]</p><h1 id="基本方案选型"><a href="#基本方案选型" class="headerlink" title="基本方案选型"></a>基本方案选型</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SLG大世界方案&quot;&gt;&lt;a href=&quot;#SLG大世界方案&quot; class=&quot;headerlink&quot; title=&quot;SLG大世界方案&quot;&gt;&lt;/a&gt;SLG大世界方案&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基本方案选型&quot;&gt;&lt;a href=&quot;#基本方案选型&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%AF%87/"/>
    <id>https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%AF%87/</id>
    <published>2023-01-05T07:33:05.754Z</published>
    <updated>2023-01-05T07:33:07.377Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E7%AF%87-%E5%AE%89%E5%8D%93/"/>
    <id>https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E7%AF%87-%E5%AE%89%E5%8D%93/</id>
    <published>2023-01-05T07:32:49.724Z</published>
    <updated>2023-01-05T08:08:01.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存(Memory)是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p><p>CPU只能访问其寄存器（Register）和内存（Memory）， 无法直接访问硬盘（Disk）。 存储在硬盘上的数据必须首先传输到内存中才能被CPU访问。从访问速度来看，对寄存器的访问非常快，通常为1纳秒； 对内存的访问相对较慢，通常为100纳秒（使用缓存加速的情况下）；而对硬盘驱动器的访问速度最慢，通常为10毫秒。</p><p>当一个程序加载到内存中时，它由四个内存区域组成：</p><p>堆栈（Stack）：存储由该程序的每个函数创建的临时变量<br>堆（Heap）：该区域特别适用于动态内存分配<br>数据（Data）：存储该程序的全局变量和静态变量<br>代码（Code）：存储该程序的指令</p><h2 id="Android之Dalvik"><a href="#Android之Dalvik" class="headerlink" title="Android之Dalvik"></a>Android之Dalvik</h2><p>Dalvik 是 Google 公司自己设计用于 Android 平台的 Java 虚拟机，Android 工程师编写的 Java 或者 Kotlin 代码最终都是在这台虚拟机中被执行的。在 Android 5.0 之前叫作 DVM，5.0 之后改为 ART（Android Runtime）。</p><p>在整个 Android 操作系统体系中，ART 位于以下图中红框位置：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h2&gt;&lt;p&gt;内存(Memory)是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>局部性和缓存命中率</title>
    <link href="https://leolichenxi.github.io/2022/02/01/%E4%BB%A3%E7%A0%81%E7%AF%87/%E5%B1%80%E9%83%A8%E6%80%A7/"/>
    <id>https://leolichenxi.github.io/2022/02/01/%E4%BB%A3%E7%A0%81%E7%AF%87/%E5%B1%80%E9%83%A8%E6%80%A7/</id>
    <published>2022-02-01T05:43:00.000Z</published>
    <updated>2022-02-21T11:12:30.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h2><h2 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;时间局部性&quot;&gt;&lt;a href=&quot;#时间局部性&quot; class=&quot;headerlink&quot; title=&quot;时间局部性&quot;&gt;&lt;/a&gt;时间局部性&lt;/h2&gt;&lt;h2 id=&quot;空间局部性&quot;&gt;&lt;a href=&quot;#空间局部性&quot; class=&quot;headerlink&quot; title=&quot;空间局</summary>
      
    
    
    
    <category term="Codes" scheme="https://leolichenxi.github.io/categories/Codes/"/>
    
    
    <category term="Codes" scheme="https://leolichenxi.github.io/tags/Codes/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leolichenxi.github.io/2021/11/18/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2021/11/18/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-18T07:20:09.089Z</published>
    <updated>2021-11-18T07:23:24.171Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity DOTS</title>
    <link href="https://leolichenxi.github.io/2021/08/30/U3D/ECS/Unity%20DOTS/"/>
    <id>https://leolichenxi.github.io/2021/08/30/U3D/ECS/Unity%20DOTS/</id>
    <published>2021-08-30T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:38.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h1><p><a href="file:///D:/Program%20Files/2020.3.14f1c1/Editor/Data/Documentation/en/Manual/JobSystem.html">官方文档</a></p><ol><li><p>借助 Unity C# 作业系统，用户可以编写与 Unity 其余部分良好交互的多线程代码，并使编写正确代码变得更加容易。</p></li><li><p>编写多线程代码可以带来高性能优势，包括显著提高帧率。将 Burst 编译器与 C# 作业配合使用可以提高代码生成质量，还可以大大降低移动设备的电池消耗。</p></li><li><p>C# 作业系统的一个重要特点是它与 Unity 内部使用的系统（Unity 的原生作业系统）相集成。用户编写的代码与 Unity 共享工作线程。此协作避免了创建超过 CPU 核心数的线程（这种情况会导致争用 CPU 资源）</p></li></ol><h3 id="NativeContainer"><a href="#NativeContainer" class="headerlink" title="NativeContainer"></a>NativeContainer</h3><blockquote><p>NativeContainer是一种托管值类型，为本机内存提供了一个相对安全的C#封装器。它包含一个指向非托管分配的指针。与Unity C# 作业系统一起使用时，NativeContainer允许Job 访问与主线程共享的数据，而不是使用副本。</p></blockquote><ul><li>NativeList - 可调整大小的 NativeArray。</li><li>NativeHashMap - 键/值对。</li><li>NativeMultiHashMap - 每个键有多个值。</li><li>NativeQueue  - 先进先出 (FIFO) 队列。</li></ul><h3 id="NativeContainer-Allocator"><a href="#NativeContainer-Allocator" class="headerlink" title="NativeContainer Allocator"></a>NativeContainer Allocator</h3><blockquote><p>创建 NativeContainer 时，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。因此，可以定制分配以便在每种情况下获得最佳性能。可以使用三种 Allocator 类型进行 NativeContainer 内存分配和释放。在实例化 NativeContainer 时需要指定适当的一种类型。</p></blockquote><ul><li>Allocator.Temp 具有最快的分配速度。此类型适用于寿命为一帧或更短的分配，不应该使用Temp将NativeContainer 分配传递给Job，在方法调用返回之前，还需要调用Dispose方法。</li></ul><p>以下错误 不应该使用Temp将NativeContainer 分配传递给Job</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public struct JobSum : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public int b;</span><br><span class="line">    public NativeArray&lt;int&gt; result;</span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] =  result[0]+ a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    void Test()</span><br><span class="line">    &#123;</span><br><span class="line">        JobSum jobSum = new JobSum();</span><br><span class="line">        jobSum.a = 1;</span><br><span class="line">        jobSum.b = 10;</span><br><span class="line">        </span><br><span class="line">        NativeArray&lt;int&gt;  result = new NativeArray&lt;int&gt;(1, Allocator.Temp );</span><br><span class="line">        jobSum.result = result;</span><br><span class="line">        var handle =  jobSum.Schedule();</span><br><span class="line">        handle.Complete();</span><br><span class="line">        result.Dispose();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Allocator.TempJob的分配速度比Temp慢，但比Persistent快。此类型适用于寿命为四帧的分配，并具有线程安全性，如果没有在四帧内对其执行Dispose,控制台会输出一条从本机代码生成的警告。大多数小作业都使用这种 NativeContainer 分配类型。</p></li><li><p>Allocator.Persistent 是最慢的分配，但可以在您所需的任意时间内持续存在，如果有必要，可以在整个应用程序的生命周期内存在。此分配器是直接调用 malloc 的封装器。持续时间较长的作业可以使用这种 NativeContainer 分配类型。在非常注重性能的情况下不应使用 Persistent。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Job-System&quot;&gt;&lt;a href=&quot;#Job-System&quot; class=&quot;headerlink&quot; title=&quot;Job System&quot;&gt;&lt;/a&gt;Job System&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;file:///D:/Program%20Files/20</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="框架" scheme="https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android 常见 Crash</title>
    <link href="https://leolichenxi.github.io/2021/08/30/U3D/ECS/AndroidCrash/"/>
    <id>https://leolichenxi.github.io/2021/08/30/U3D/ECS/AndroidCrash/</id>
    <published>2021-08-30T04:00:00.000Z</published>
    <updated>2023-03-16T03:30:12.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Crash"><a href="#Android-Crash" class="headerlink" title="Android Crash"></a>Android Crash</h1><p><a href="https://developer.android.com/games/optimize/crash?hl=zh-cn">Android官网检测和诊断崩溃问题</a></p><p>Android 6.0的源码剖析<a href="http://gityuan.com/2016/06/24/app-crash/">理解Android Crash处理流程</a></p><p><a href="https://zhuanlan.zhihu.com/p/77984555">unity crash 的快速定位</a></p><p>基本概念：</p><ul><li>ANR </li></ul><p>用户在使用App过程中出现弹框，提示应用无响应，计为一次ANR，ANR仅用于Android平台应用。</p><ul><li>Java Crash</li></ul><p>Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出，Jvm虚拟机退出，系统弹框提醒用户，这个我们可以看log查看报错原因，Crash工具都能捕获到。</p><ul><li>Native Crash</li></ul><p>那 Native 崩溃一般都是因为Native代码中访问非法地址或者是地址对齐出现问题，再或者是发生程序主动abort，这些都会产生对应的signal信号，导致程序异常退出</p><ul><li>SIGSEGV </li></ul><p>一般是由于空指针、非法指针造成</p><ul><li>SIGABRT</li></ul><p>后者主要因为 ANR 和调用abort()退出所导致。</p><h1 id="Crash常见原因"><a href="#Crash常见原因" class="headerlink" title="Crash常见原因"></a>Crash常见原因</h1><ul><li><p>OOM</p><p>代码层或资源内存泄漏</p><ol><li>java.lang.outofmemory</li><li>GL_OUT_OF_MEMORY </li><li>vukan out of memory</li></ol></li><li><p>NullPointerException </p><p>空指针异常</p></li><li><p>IndexOutOfBoundsException</p><p>数组、集合等越界</p></li><li><p>java.lang.StackOverflowError </p><p>堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误，（死循环了等）</p></li><li><p>ClassCastException </p><p>类型转换异常 </p></li><li><p>ActivityNotFoundException </p><p>Activity未找到异常</p></li><li><p>SecurityException </p><p>安全异常 </p></li><li><p>llegalArgumentException: Service not registered </p><p>服务未注册异常 </p></li><li><p>BadTokenException</p></li><li><p>API 平台兼容性<br>Unity 的一些API在不同硬件的兼容性问题</p></li></ul><h2 id="错误符号"><a href="#错误符号" class="headerlink" title="错误符号"></a>错误符号</h2><ol><li><p>SIGSEGV 段错误</p><p>SEGV_MAPERR    要访问的地址没有映射到内存空间。 比如上面对空指针的写操作， 当指针被意外复写为一个较小的数值时。</p><p>SEGV_ACCERR    访问的地址没有权限。比如试图对代码段进行写操作。</p></li><li><p>SIGFPE 浮点错误，一般发生在算术运行出错时。</p><p>FPE_INTDIV    除以0</p><p>FPE_INTOVE    整数溢出</p></li><li><p>SIGBUS 总线错误<br>BUS_ADRALN    地址对齐出错。arm cpu比x86 cpu 要求更严格的对齐机制，所以在 arm cpu 机器中比较常见。</p></li><li><p>SIGILL 发生这种错误一般是由于某处内存被意外改写了。</p><p>ILL_ILLOPC    非法的指令操作码</p><p>ILL_ILLOPN    非法的指令操作数</p></li><li><p>当调用堆栈中出现 stack_chk_fail 函数时，一般是由于比如 strcpy 之类的函数调用将栈上的内容覆盖，而引起栈检查失败。</p></li></ol><p><img src="/images/crash/Signum.jpeg" alt="枚举"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><p>一般分为Java Crash 和 Native Crash</p></blockquote><h2 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>出错时界面不会弹出提示框提醒程序崩溃（Android 5.0以下）</li><li>出错时会弹出提示框提醒程序崩溃（Android 5.0以上）</li><li>程序会直接闪退到系统桌面</li><li>这类错误一般是由C++层代码错误引起的</li><li>绝大部分Crash工具不能够捕获</li></ol><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><h1 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h1><ol><li>堆栈信息查找</li><li>log日志，尤其是warning error相关;</li><li>机型信息  GPU 内存 系统 厂商 信息等共性信息，(有可能某个厂商特定修改);</li><li>复现步骤;</li><li>前后台信息;</li><li>图形API vukan opengl 版本的bug.</li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>addr2line，objdump，ndk-stack等几个工具</p><h1 id="crash上报第三方"><a href="#crash上报第三方" class="headerlink" title="crash上报第三方"></a>crash上报第三方</h1><p>CrashSight Bugly Firebase</p><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-Crash&quot;&gt;&lt;a href=&quot;#Android-Crash&quot; class=&quot;headerlink&quot; title=&quot;Android Crash&quot;&gt;&lt;/a&gt;Android Crash&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="其它" scheme="https://leolichenxi.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>CSharpLua</title>
    <link href="https://leolichenxi.github.io/2021/06/17/Tools/CSharp.lua/"/>
    <id>https://leolichenxi.github.io/2021/06/17/Tools/CSharp.lua/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2021-06-17T11:12:00.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSharpLua"><a href="#CSharpLua" class="headerlink" title="CSharpLua"></a>CSharpLua</h1><p>一个翻译c#为Lua的工具<br>Git地址<a href="https://github.com/yanghuan/CSharp.lua.git">Charp.lua</a></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">D:\&gt;dotnet CSharp.Lua.Launcher.dll -h</span><br><span class="line">Usage: CSharp.lua [-s srcfolder] [-d dstfolder]</span><br><span class="line">Arguments</span><br><span class="line">-s              : can be a directory where all cs files will be compiled, or a list of files, using &#x27;;&#x27; or &#x27;,&#x27; to separate</span><br><span class="line">-d              : destination directory, will put the out lua files</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">-h              : show the help message and exit</span><br><span class="line">-l              : libraries referenced, use &#x27;;&#x27; to separate</span><br><span class="line">                  if the librarie is a module, whitch is compield by CSharp.lua with -module arguemnt, the last character needs to be &#x27;!&#x27; in order to mark  </span><br><span class="line"></span><br><span class="line">-m              : meta files, like System.xml, use &#x27;;&#x27; to separate</span><br><span class="line">-csc            : csc.exe command argumnets, use &#x27; &#x27; or &#x27;\t&#x27; to separate</span><br><span class="line"></span><br><span class="line">-c              : support classic lua version(5.1), default support 5.3</span><br><span class="line">-a              : attributes need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-a&quot;&quot; only, all attributes whill be exported</span><br><span class="line">-e              : enums need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-e&quot;&quot; only, all enums will be exported</span><br><span class="line">-ei             : enums is represented by a variable reference rather than a constant value, need to be used with -e</span><br><span class="line">-p              : do not use debug.setmetatable, in some Addon/Plugin environment debug object cannot be used</span><br><span class="line">-metadata       : export all metadata, use @CSharpLua.Metadata annotations for precise control</span><br><span class="line">-module         : the currently compiled assembly needs to be referenced, it&#x27;s useful for multiple module compiled</span><br><span class="line">-inline-property: inline some single-line properties</span><br><span class="line">-include        : the root directory of the CoreSystem library, adds all the dependencies to a single file named out.lua</span><br><span class="line">-noconcurrent   : close concurrent compile</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><p>打开 CSharp.lua.sln<br>自己可编译 我这里选择 Release Build</p><p><img src="/images/csharplua/2.png" alt="截图"></p><p>红色标记处为编译成功后</p><p>这里新建一个文件夹将上图红色标记文件拷出</p><p><img src="/images/csharplua/3.png" alt="截图"></p><p>cmd测试： dotnet CSharp.lua.Launcher.dll -h</p><p><img src="/images/csharplua/1.png" alt="截图"></p><h3 id="编译c-工程"><a href="#编译c-工程" class="headerlink" title="编译c# 工程"></a>编译c# 工程</h3><p>lua 使用的 5.3 版本</p><p>新建 CompileScript Console工程,新增文件夹Core<br>创建测试脚本 </p><p>Test.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    public class Test</span><br><span class="line">    &#123;</span><br><span class="line">        public int a;</span><br><span class="line">        public int b;</span><br><span class="line"></span><br><span class="line">        public Test()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(a + b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TestClass2.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    class TestClass2</span><br><span class="line">    &#123;</span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">            Test t = new Test();</span><br><span class="line">            t.Debug();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>命令行： dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export</p></blockquote><p>在Export 下创建lua工程<br>将<img src="/images/csharplua/4.png" alt="截图"> copy 到工程，新建main.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;All&quot;)()</span><br><span class="line">require(&quot;manifest&quot;)()</span><br><span class="line"></span><br><span class="line">local baseTime = System.DateTime(1970, 1, 1)</span><br><span class="line">print(baseTime:ToString())</span><br><span class="line"></span><br><span class="line">local t = CompileScript.Core.Test()</span><br><span class="line">t.a = 10</span><br><span class="line">t:Debug()</span><br></pre></td></tr></table></figure><p>运行 可以</p><p>将<img src="/images/csharplua/5.png" alt="截图"> copy 到工程，新建main.lua</p><h3 id="第三方库引用"><a href="#第三方库引用" class="headerlink" title="第三方库引用"></a>第三方库引用</h3><p>CompileScript 工程添加Newtonsoft库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Newtonsoft.Json;</span><br><span class="line">namespace CompileScript.Core</span><br><span class="line">&#123;</span><br><span class="line">    public class Test</span><br><span class="line">    &#123;</span><br><span class="line">        public int a;</span><br><span class="line">        public int b;</span><br><span class="line"></span><br><span class="line">        public Test()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Debug()</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">            Console.WriteLine(a + b);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(JsonConvert.SerializeObject(this));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译指令</p><blockquote><p>G:\Learning\CsharpLua\CSharpLuaTools&gt;dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export -l ../3rd/Newtonsoft.Json.dll</p></blockquote><p>运行代码 报错</p><p><img src="/images/csharplua/6.png" alt="截图"></p><blockquote><p>这里第三方库dll的实现需要自己适配</p></blockquote><p>这里适配 NewtonsoftJson.JsonConvert.SerializeObject(this)</p><p>新建 NewtonsoftJson.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Newtonsoft = &#123;&#125;</span><br><span class="line">Newtonsoft.Json = &#123;&#125;</span><br><span class="line">Newtonsoft.Json.JsonConvert = &#123;&#125;</span><br><span class="line">Newtonsoft.Json.JsonConvert.SerializeObject = function (obj)</span><br><span class="line">     return &quot;todo&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return Newtonsoft</span><br></pre></td></tr></table></figure><p>return “todo”可修改为lua相关的json库，比如cjson</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>第三方库的依赖尽量少依赖</li><li>如果有需要查看适配结果，多测试</li><li>核心库CoreSystem.Lua 文件夹下的适配了多数System。</li></ul><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>如果手写Lua 需要调用翻译的lua class 时，如果不知道如何new对象等，参考TestClass2, 创建一个专门的class 用来测试 翻译出的如何new 对象。</p><h3 id="适配踩坑"><a href="#适配踩坑" class="headerlink" title="适配踩坑"></a>适配踩坑</h3><p>Unity工程适配 ToLua支持，Xlua 实际测试不支持，如果在Xlua 使用，不得依赖UnityEngine 相关库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSharpLua&quot;&gt;&lt;a href=&quot;#CSharpLua&quot; class=&quot;headerlink&quot; title=&quot;CSharpLua&quot;&gt;&lt;/a&gt;CSharpLua&lt;/h1&gt;&lt;p&gt;一个翻译c#为Lua的工具&lt;br&gt;Git地址&lt;a href=&quot;https://git</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="Charp Lua" scheme="https://leolichenxi.github.io/tags/Charp-Lua/"/>
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="https://leolichenxi.github.io/2021/06/17/Tools/Cmake/"/>
    <id>https://leolichenxi.github.io/2021/06/17/Tools/Cmake/</id>
    <published>2021-06-17T04:00:00.000Z</published>
    <updated>2023-06-13T02:38:55.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMAKE-使用"><a href="#CMAKE-使用" class="headerlink" title="CMAKE 使用"></a>CMAKE 使用</h1><p>考虑到在项目中定义Native库和编译其它的开源Native库，客户端往往对编译原理计算机基础比较薄弱，记录下CMake使用笔记</p><p>主要从官网记录</p><p><a href="https://cmake.org/">CMake官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMAKE-使用&quot;&gt;&lt;a href=&quot;#CMAKE-使用&quot; class=&quot;headerlink&quot; title=&quot;CMAKE 使用&quot;&gt;&lt;/a&gt;CMAKE 使用&lt;/h1&gt;&lt;p&gt;考虑到在项目中定义Native库和编译其它的开源Native库，客户端往往对编译原理计算机基</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="CMake" scheme="https://leolichenxi.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>四叉树</title>
    <link href="https://leolichenxi.github.io/2021/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91/"/>
    <id>https://leolichenxi.github.io/2021/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-06-14T05:37:26.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h1><p><a href="https://zh.wikipedia.org/wiki%E5%9B%9B%E5%8F%89%E6%A0%91">四叉树Wiki</a></p><blockquote><p>四叉树是一种树状数据结构，在每一个节点上会有四个子区块。四叉树常应用于二维空间资料的分析与分类。 它将资料区分成为四个象限。资料范围可以是方形或矩形或其他任意形状。这种数据结构是由 拉斐尔·芬科尔(Raphael Finkel) 与 J. L. Bentley 在1974年发展出来 。 类似的资料分割方法也称为 Q-tree。 所有的四叉树法有共同之特点:</p></blockquote><ol><li>可分解成为各自的区块</li><li>每个区块都有节点容量。当节点达到最大容量时，节点分裂</li><li>树状数据结构依造四叉树法加以区分</li></ol><h1 id="根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下"><a href="#根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下" class="headerlink" title="根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下"></a>根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下</h1><h2 id="只要点在区域内就可以插入"><a href="#只要点在区域内就可以插入" class="headerlink" title="只要点在区域内就可以插入"></a>只要点在区域内就可以插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public class TreeRect</span><br><span class="line">&#123;</span><br><span class="line">    public float X &#123; get; private set; &#125;</span><br><span class="line">    public float Y &#123; get; private set; &#125;</span><br><span class="line">    public float W &#123; get; private set; &#125;</span><br><span class="line">    public float H &#123; get; private set; &#125;</span><br><span class="line">    public float HalfW &#123; get; private set; &#125;</span><br><span class="line">    public float HalfH &#123; get; private set; &#125;</span><br><span class="line">    public float XL &#123; get; private set; &#125;</span><br><span class="line">    public float XR&#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public float YT &#123; get; private set; &#125;</span><br><span class="line">    public float YB &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public TreeRect(float x, float y)</span><br><span class="line">    &#123;</span><br><span class="line">        SetRect(x, y, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 四边形</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;w&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;h&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public TreeRect(float x, float y, float w, float h)</span><br><span class="line">    &#123;</span><br><span class="line">        SetRect(x, y, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void SetRect(float x, float y, float w, float h)</span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line"></span><br><span class="line">        HalfW = W * 0.5f;</span><br><span class="line">        HalfH = H * 0.5f;</span><br><span class="line"></span><br><span class="line">        XL = X - HalfW;</span><br><span class="line">        XR = X + HalfW;</span><br><span class="line">        YB = Y - HalfH;</span><br><span class="line">        YT = Y + HalfH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return (!(XR &lt; other.XL || XL &gt; other.XR)) &amp;&amp; (!(YT &lt; other.YB || YB &gt; other.YT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsCenterIn(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return other.X &lt;= XR &amp;&amp; other.X &gt;= XL &amp;&amp; other.Y &lt;= YT &amp;&amp; other.Y &gt;= YB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsIn(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return XR &lt;= other.XR  &amp;&amp; XL &gt;= other.XL &amp;&amp; YT &lt;= other.YT &amp;&amp; YB &gt;= other.YB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;(&#123;X&#125;,&#123;Y&#125;,&#123;W&#125;,&#123;H&#125;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static TreeRect operator *(TreeRect rhs,float lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.SetRect(rhs.X * lhs, rhs.Y * lhs, rhs.W * lhs,  rhs.H * lhs);</span><br><span class="line">        return rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TreeObject</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 信息</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public TreeRect TreeRect;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 属于哪个节点</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public MapQuadTree Node ;</span><br><span class="line">    public int Id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapQuadTree</span><br><span class="line">&#123;</span><br><span class="line">    public MapQuadTree Root &#123; get; &#125; //根节点</span><br><span class="line">    public int MaxCount &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int MaxDeep &#123; get; private set; &#125; = 4;</span><br><span class="line">    public int TreeDeep &#123; get; &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;MapQuadTree&gt; Childs &#123; get; private set; &#125; </span><br><span class="line">    public MapQuadTree Parent &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public readonly List&lt;TreeObject&gt; TreePointObjs = new List&lt;TreeObject&gt;();</span><br><span class="line"></span><br><span class="line">    // public readonly List&lt;TreeObject&gt; BoundTreeObjs = new List&lt;TreeObject&gt;();</span><br><span class="line">    public TreeRect Rect &#123; get; &#125;</span><br><span class="line">    public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0;</span><br><span class="line">    public bool IsEmptyLeafNode =&gt; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode ;</span><br><span class="line"></span><br><span class="line">    public MapQuadTree(TreeRect rect)</span><br><span class="line">    &#123;</span><br><span class="line">        Rect = rect;</span><br><span class="line">        TreeDeep = 0;</span><br><span class="line">        Root = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MapQuadTree(TreeRect rect, int treeDeep, MapQuadTree parent) : this(rect)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeDeep = treeDeep + 1;</span><br><span class="line">        this.Parent = parent;</span><br><span class="line">        Root = parent.Root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Insert(TreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!IsInTreeRect(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeObj.Node = this;</span><br><span class="line">        if (Childs == null)</span><br><span class="line">        &#123;</span><br><span class="line">            TreePointObjs.Add(treeObj);</span><br><span class="line">            if (TreePointObjs.Count &gt; MaxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                SliceTree();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[i].Insert(treeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SliceTree()</span><br><span class="line">    &#123;</span><br><span class="line">        if (TreeDeep &gt;= MaxDeep)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 四分 可根据情况 调整</span><br><span class="line">        // lb, lt, rt, rb  目前与unity recttranform 的 4个 corner 保持一致的分布顺序</span><br><span class="line">        Childs = new List&lt;MapQuadTree&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this),</span><br><span class="line">            new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; TreePointObjs.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; Childs.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[j].Insert(TreePointObjs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreePointObjs.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.Intersect(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsInTreeRect(TreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.IsCenterIn(treeObj.TreeRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ClearEmptyNode()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;MapQuadTree&gt; emptyLeafNodes = new List&lt;MapQuadTree&gt;();</span><br><span class="line">        ForEachEmptyLeafNode(Root, (t) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            emptyLeafNodes.Add(t);</span><br><span class="line">        &#125;);</span><br><span class="line">        while (emptyLeafNodes.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; emptyLeafNodes.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            emptyLeafNodes.Clear();</span><br><span class="line">            ForEachEmptyLeafNode(Root, (t) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes.Add(t);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachEmptyLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsEmptyLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachEmptyLeafNode(node.Childs[i],treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void ForEachLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachLeafNode(node.Childs[i],treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void RemoveChildNode(MapQuadTree node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Childs!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            Childs.Remove(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void ForEach(Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEach(Root, each);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;MapQuadTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;TreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;TreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var treeObject in node.TreePointObjs)</span><br><span class="line">            &#123;</span><br><span class="line">                treeAction?.Invoke(treeObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEach(MapQuadTree node, Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForEachNodeValues(node, each);</span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachNodeValues(node.Childs[i], each);</span><br><span class="line">                ForEach(node.Childs[i], each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachNodeValues(MapQuadTree node, Action&lt;MapQuadTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        each?.Invoke(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只要点和边框必须在区域内就可以插入"><a href="#只要点和边框必须在区域内就可以插入" class="headerlink" title="只要点和边框必须在区域内就可以插入"></a>只要点和边框必须在区域内就可以插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BoundTreeObject</span><br><span class="line">&#123;</span><br><span class="line">    public TreeRect TreeRect;</span><br><span class="line">    public MapQuadBoundTree Node;</span><br><span class="line">    public int Id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapQuadBoundTree</span><br><span class="line">&#123;</span><br><span class="line">    public MapQuadBoundTree Root &#123; get; &#125; //根节点</span><br><span class="line">    public int MaxCount &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int MaxDeep &#123; get; private set; &#125; = 5;</span><br><span class="line">    public int TreeDeep &#123; get; &#125;</span><br><span class="line">    public List&lt;MapQuadBoundTree&gt; Childs &#123; get; private set; &#125;</span><br><span class="line">    public MapQuadBoundTree Parent &#123; get; &#125;</span><br><span class="line">    private TreeRect[] _treeChildRects = new TreeRect[4];</span><br><span class="line">    public readonly List&lt;BoundTreeObject&gt; TreePointObjs = new List&lt;BoundTreeObject&gt;();</span><br><span class="line"></span><br><span class="line">    public readonly List&lt;BoundTreeObject&gt; BoundTreeObjs = new List&lt;BoundTreeObject&gt;();</span><br><span class="line">    public TreeRect Rect &#123; get; &#125;</span><br><span class="line">    public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0;</span><br><span class="line">    public bool IsEmptyLeafNode =&gt; BoundTreeObjs.Count == 0 &amp;&amp; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode;</span><br><span class="line"></span><br><span class="line">    public MapQuadBoundTree(TreeRect rect)</span><br><span class="line">    &#123;</span><br><span class="line">        Rect = rect;</span><br><span class="line">        TreeDeep = 0;</span><br><span class="line">        Root = this;</span><br><span class="line">        _treeChildRects[0] =</span><br><span class="line">            new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[1] =</span><br><span class="line">            new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[2] =</span><br><span class="line">            new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">        _treeChildRects[3] =</span><br><span class="line">            new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MapQuadBoundTree(TreeRect rect, int treeDeep, MapQuadBoundTree parent) : this(rect)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeDeep = treeDeep + 1;</span><br><span class="line">        this.Parent = parent;</span><br><span class="line">        Root = parent.Root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Insert(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!IsInTreeRect(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeObj.Node = this;</span><br><span class="line">        if (IsAllInsert(treeObj))</span><br><span class="line">        &#123;</span><br><span class="line">            BoundTreeObjs.Add(treeObj);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Childs == null)</span><br><span class="line">        &#123;</span><br><span class="line">            TreePointObjs.Add(treeObj);</span><br><span class="line">            if (TreePointObjs.Count &gt; MaxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                SliceTree();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[i].Insert(treeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsAllInsert(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; _treeChildRects.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_treeChildRects[i].Intersect(treeObj.TreeRect))</span><br><span class="line">            &#123;</span><br><span class="line">                if (count &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SliceTree()</span><br><span class="line">    &#123;</span><br><span class="line">        if (TreeDeep &gt;= MaxDeep)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // lb, lt, rt, rb  目前与unity recttranform 的 4个 corner 保持一致的分布顺序</span><br><span class="line">        Childs = new List&lt;MapQuadBoundTree&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this),</span><br><span class="line">            new MapQuadBoundTree(</span><br><span class="line">                new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep,</span><br><span class="line">                this)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; TreePointObjs.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; Childs.Count; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Childs[j].Insert(TreePointObjs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreePointObjs.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool Intersect(TreeRect other)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.Intersect(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private bool IsInTreeRect(BoundTreeObject treeObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rect.IsCenterIn(treeObj.TreeRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ClearEmptyNode()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO  清除空节点 只需从叶节点删除</span><br><span class="line">        List&lt;MapQuadBoundTree&gt; emptyLeafNodes = new List&lt;MapQuadBoundTree&gt;();</span><br><span class="line">        ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;);</span><br><span class="line">        while (emptyLeafNodes.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; emptyLeafNodes.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            emptyLeafNodes.Clear();</span><br><span class="line">            ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachEmptyLeafNode(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.IsEmptyLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachEmptyLeafNode(node.Childs[i], treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void RemoveChildNode(MapQuadBoundTree node)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Childs.Remove(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void ForEach(Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEach(Root, each);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            treeAction?.Invoke(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ForEachInRect(TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        ForEachAreaTree(Root, rect, treeAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!node.Rect.Intersect(rect))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreach (var boundTreeObj in node.BoundTreeObjs)</span><br><span class="line">        &#123;</span><br><span class="line">            if (boundTreeObj.TreeRect.Intersect(rect))</span><br><span class="line">            &#123;</span><br><span class="line">                treeAction?.Invoke(boundTreeObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.IsLeafNode)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var boundTreeObj in node.TreePointObjs)</span><br><span class="line">            &#123;</span><br><span class="line">                if (boundTreeObj.TreeRect.Intersect(rect))</span><br><span class="line">                &#123;</span><br><span class="line">                    treeAction?.Invoke(boundTreeObj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachAreaTree(node.Childs[i], rect, treeAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEach(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForEachNodeValues(node, each);</span><br><span class="line">        if (node.Childs != null)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; node.Childs.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ForEachNodeValues(node.Childs[i], each);</span><br><span class="line">                ForEach(node.Childs[i], each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ForEachNodeValues(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each)</span><br><span class="line">    &#123;</span><br><span class="line">        each?.Invoke(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四叉树&quot;&gt;&lt;a href=&quot;#四叉树&quot; class=&quot;headerlink&quot; title=&quot;四叉树&quot;&gt;&lt;/a&gt;四叉树&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki%E5%9B%9B%E5%8F%89%E6%A0%91&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leolichenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="https://leolichenxi.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GoogleProtobuffer</title>
    <link href="https://leolichenxi.github.io/2021/06/14/Tools/GoogleProtobuffer/"/>
    <id>https://leolichenxi.github.io/2021/06/14/Tools/GoogleProtobuffer/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-06-16T08:51:50.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protocolbuffers"><a href="#Protocolbuffers" class="headerlink" title="Protocolbuffers"></a>Protocolbuffers</h1><ul><li><a href="https://github.com/protocolbuffers/protobuf">官方git地址</a></li><li><a href="https://developers.google.com/protocol-buffers">官方文档地址</a></li><li><a href="https://github.com/protocolbuffers/protobuf/releases">官方Release</a></li><li><a href="https://zhuanlan.zhihu.com/p/38200420">知乎介绍</a></li></ul><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>常见的数据格式：XML,Json,Protobuf,FlatBuffers 等其它。</p><ul><li>数据储存</li><li>数据交换格式</li></ul><p>使用流程：</p><p>1.编写Scheme;<br>2.使用Protoc 生成代码；</p><h2 id="下载Release-Protoc代码生成工具"><a href="#下载Release-Protoc代码生成工具" class="headerlink" title="下载Release Protoc代码生成工具"></a>下载Release Protoc代码生成工具</h2><blockquote><p>Release中下载Window 或 Mac Os<br><img src="/images/protobuffer/1.png" alt="截图"></p></blockquote><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>在下载程序后，需要将下载 zip 文件中的 bin 目录设置到环境变量中。</p><p>然后运行 protoc –version 来确定你的编译运行版本已经被正确配置。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://developers.google.com/protocol-buffers">官方文档地址</a></p><p>生成代码命令</p><blockquote><p>eg:   protoc – csharp_out=SciptOutFolder/  ProtoFolder/filename.proto</p></blockquote><h3 id="Protocol-Buffer-编码原理"><a href="#Protocol-Buffer-编码原理" class="headerlink" title="Protocol Buffer 编码原理"></a>Protocol Buffer 编码原理</h3><p>采用Varint编码规则</p><h4 id="Varint编码"><a href="#Varint编码" class="headerlink" title="Varint编码"></a>Varint编码</h4><p>variant是可变长的编码方式,Varint是一种使用一个或多个字节序列化整数的方法，会把整数编码变为长字节，对于32位整型进过Variant编码后需要1-5个字节,小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用1~10个字节。在实际场景中小数字的使用率远远大于大数字，因此Varint编码对于大部分的场景都可以起到很好的压缩效果。</p><h5 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h5><p>除了最后一个字节外,Varint编码中的每个字节都设置了最高有效位（most significant bit - msb）–msb为1则表明后面的字节还是属于当前数据的,如果是0那么这是当前数据的最后一个字节数据。每个字节的第7位用于以7位为一组存储数字的二进制补码表示，最低有效组在前，或者叫最低有效字节在前。这表明varint编码后数据的字节是按照小端序排列的。</p><p>关于字节排列的方式引用一下维基百科上的词条</p><blockquote><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p></blockquote><p>通俗一点说就是：大端序是按照数字的书写顺序排列的，而小端序是颠倒书写顺序进行排列的。</p><blockquote><p>variant编码对负数编码效率低</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Protocolbuffers&quot;&gt;&lt;a href=&quot;#Protocolbuffers&quot; class=&quot;headerlink&quot; title=&quot;Protocolbuffers&quot;&gt;&lt;/a&gt;Protocolbuffers&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Tools" scheme="https://leolichenxi.github.io/categories/Tools/"/>
    
    
    <category term="GoogleProtobuffer" scheme="https://leolichenxi.github.io/tags/GoogleProtobuffer/"/>
    
  </entry>
  
  <entry>
    <title>ECS架构</title>
    <link href="https://leolichenxi.github.io/2021/06/14/U3D/ECS/ECS%E6%9E%B6%E6%9E%84/"/>
    <id>https://leolichenxi.github.io/2021/06/14/U3D/ECS/ECS%E6%9E%B6%E6%9E%84/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:33.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ECS ,即  Entity-Component-System 的缩写，其模式遵循组合优于继承原则，游戏内的每一个单位都是一个实体，每个实体又又一个或多个组件构成，每个组件仅仅包含代表其特性的数据(即在组件中没有任何方法),系统便是来处理拥有一个或多个相同组件的实体集合的工具，其只拥有行为，在这个例子中，处理移动的系统仅仅关心拥有移动能力的实体，它会遍历所有拥有相关组件的实体，并根据相关的数据，更新实体。</p></blockquote><p><img src="/images/ecs/1.png" alt="截图"></p><p>这里核心思路区别于Unity ECS，提供一个设计思路。Unity 后面单独研究下</p><p>ECS 获取组件较为麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ECS ,即  Entity-Component-System 的缩写，其模式遵循组合优于继承原则，游戏内的每一个单位都是一个实体，每个实体又又一个或多个组件构成，每个组件仅仅包含代表其特性的数据(即在组件中没有任何方法),系统便是来处理拥有一个或</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="框架" scheme="https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>开发流程-客户端-策划配置数据</title>
    <link href="https://leolichenxi.github.io/2021/06/14/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AD%96%E5%88%92%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://leolichenxi.github.io/2021/06/14/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AD%96%E5%88%92%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2021-08-11T09:36:14.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端配置数据管理"><a href="#客户端配置数据管理" class="headerlink" title="客户端配置数据管理"></a>客户端配置数据管理</h1><blockquote><p>开发或上线后不可避免的出现配置逻辑错误问题，系统功能通常会给策划留有很大的配置空间用于铺量和修改，但不可避免的会有错误，这里记录下配置表检查的原则</p></blockquote><h3 id="必须检查的情况"><a href="#必须检查的情况" class="headerlink" title="必须检查的情况"></a>必须检查的情况</h3><ol><li>id 与其它表格关联</li><li>配置资源路径，必须判断资源是否存在</li><li>配置要求一定得格式，比如约定的分隔符 1;2 分割数组，可能会配置成1,2</li><li>有 type:id  type 不同id 指向不用配置表，必须检查。</li><li>未完待续…..</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;客户端配置数据管理&quot;&gt;&lt;a href=&quot;#客户端配置数据管理&quot; class=&quot;headerlink&quot; title=&quot;客户端配置数据管理&quot;&gt;&lt;/a&gt;客户端配置数据管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;开发或上线后不可避免的出现配置逻辑错误问题，系统功能通常会</summary>
      
    
    
    
    <category term="开发流程" scheme="https://leolichenxi.github.io/categories/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
    <category term="开发流程" scheme="https://leolichenxi.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>1.从Unlit-Color开始入手</title>
    <link href="https://leolichenxi.github.io/2021/06/14/Shader/1%E7%AC%94%E8%AE%B0_builtin_shaders_Unlit-Color/"/>
    <id>https://leolichenxi.github.io/2021/06/14/Shader/1%E7%AC%94%E8%AE%B0_builtin_shaders_Unlit-Color/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:10:49.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shader-源码-Unlit-Color"><a href="#Shader-源码-Unlit-Color" class="headerlink" title="Shader 源码-Unlit-Color"></a>Shader 源码-Unlit-Color</h1><p>需要有一定的shader基础，深刻理解unity 内置shader的实现原里。</p><blockquote><p>先贴代码，逐步分析</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)</span><br><span class="line"></span><br><span class="line">// Unlit shader. Simplest possible colored shader.</span><br><span class="line">// - no lighting</span><br><span class="line">// - no lightmap support</span><br><span class="line">// - no texture</span><br><span class="line"></span><br><span class="line">Shader &quot;Unlit/Color&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">        LOD 100</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma target 2.0</span><br><span class="line">            #pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata_t</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: SV_POSITION;</span><br><span class="line">                UNITY_FOG_COORDS(0)</span><br><span class="line">                UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_t v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                UNITY_SETUP_INSTANCE_ID(v);</span><br><span class="line">                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o, o.vertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i): SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = _Color;</span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                UNITY_OPAQUE_ALPHA(col.a);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pragma-multi-compile-fog"><a href="#pragma-multi-compile-fog" class="headerlink" title="#pragma multi_compile_fog"></a>#pragma multi_compile_fog</h2><p>实现很简单，重点点记录</p><ul><li>#pragma multi_compile_fog</li><li>UNITY_VERTEX_INPUT_INSTANCE_ID</li><li>UNITY_FOG_COORDS(0)</li><li>UNITY_VERTEX_OUTPUT_STEREO</li><li>UNITY_SETUP_INSTANCE_ID(v)</li><li>UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o)</li><li>UNITY_TRANSFER_FOG(o, o.vertex)</li><li>UNITY_APPLY_FOG(i.fogCoord, col)</li><li>UNITY_OPAQUE_ALPHA(col.a)</li></ul><p>这些在一个基础的顶点片元着色器的基本原里。</p><h3 id="基础概念宏定义"><a href="#基础概念宏定义" class="headerlink" title="基础概念宏定义"></a>基础概念宏定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define 标识  //定义标识，如果 （标识） 已经被标识过会报错。</span><br><span class="line">#undef 标识   //取消标识的定义</span><br><span class="line">#ifdef 标识   //判断某个宏是否被定义，若已定义，执行随后的语句</span><br><span class="line">#ifndef 标示  // 判断&quot;标示&quot;是否定义，如果被定义则返回false，如果没有被定义则返回true</span><br><span class="line"></span><br><span class="line">#if           //编译预处理中的条件命令，相当于C语法中的if语句</span><br><span class="line">#elif         // 若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if</span><br><span class="line">#else         //与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else</span><br><span class="line">#endif        //#if, #ifdef, #ifndef这些条件命令的结束标志.  </span><br><span class="line">defined(宏)        与#if, #elif配合使用，判断某个宏是否被定义</span><br></pre></td></tr></table></figure><h3 id="include-“UnityCG-cginc”"><a href="#include-“UnityCG-cginc”" class="headerlink" title="#include “UnityCG.cginc”"></a>#include “UnityCG.cginc”</h3><p>这里需要注意下,include并不是像c++ 这样在调用shader时将文件include进去，而是在编译shader时决定生成的代码。可以测试在去掉#pragma multi_compile_fog前后点击shader面板 Compile and show code 查看编译后的代码。</p><p>追到UnityCG.cginc文件中查看UNITY_FOG_COORDS宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)</span><br><span class="line">    #define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1)</span><br><span class="line"></span><br><span class="line">    #if (SHADER_TARGET &lt; 30) || defined(SHADER_API_MOBILE)</span><br><span class="line">        // mobile or SM2.0: calculate fog factor per-vertex</span><br><span class="line">        #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.tSpace1.y = tangentSign; o.tSpace2.y = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.worldPos.w = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.eyeVec.w = unityFogFactor</span><br><span class="line">    #else</span><br><span class="line">        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel</span><br><span class="line">        #define UNITY_TRANSFER_FOG(o,outpos) o.fogCoord.x = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) o.tSpace2.y = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) o.worldPos.w = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) o.eyeVec.w = (outpos).z</span><br><span class="line">    #endif</span><br><span class="line">#else</span><br><span class="line">    #define UNITY_FOG_COORDS(idx)</span><br><span class="line">    #define UNITY_TRANSFER_FOG(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当开启Fog时 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1)</span><br></pre></td></tr></table></figure><blockquote><p>UNITY_FOG_COORDS_PACKED</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UNITY_FOG_COORDS_PACKED(idx, vectype) vectype fogCoord : TEXCOORD##idx;</span><br></pre></td></tr></table></figure><p>可知实际 UNITY_FOG_COORDS(0) 如果Fog开启,相当一在片元数据中定义了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float1 fogCoord : TEXCOORD0</span><br></pre></td></tr></table></figure><blockquote><p>UNITY_TRANSFER_FOG</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)</span><br><span class="line">    #define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1)</span><br><span class="line"></span><br><span class="line">    #if (SHADER_TARGET &lt; 30) || defined(SHADER_API_MOBILE)</span><br><span class="line">        // mobile or SM2.0: calculate fog factor per-vertex</span><br><span class="line">        #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.tSpace1.y = tangentSign; o.tSpace2.y = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.worldPos.w = unityFogFactor</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.eyeVec.w = unityFogFactor</span><br><span class="line">    #else</span><br><span class="line">        // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel</span><br><span class="line">        #define UNITY_TRANSFER_FOG(o,outpos) o.fogCoord.x = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) o.tSpace2.y = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) o.worldPos.w = (outpos).z</span><br><span class="line">        #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) o.eyeVec.w = (outpos).z</span><br><span class="line">    #endif</span><br><span class="line">#else</span><br><span class="line">    #define UNITY_FOG_COORDS(idx)</span><br><span class="line">    #define UNITY_TRANSFER_FOG(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos)</span><br><span class="line">    #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos)</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为   #pragma target 2.0 时 SHADER_TARGET &lt;30 所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if defined(FOG_LINEAR)</span><br><span class="line">    // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start))</span><br><span class="line">    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = (coord) * unity_FogParams.z + unity_FogParams.w</span><br><span class="line">#elif defined(FOG_EXP)</span><br><span class="line">    // factor = exp(-density*z)</span><br><span class="line">    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.y * (coord); unityFogFactor = exp2(-unityFogFactor)</span><br><span class="line">#elif defined(FOG_EXP2)</span><br><span class="line">    // factor = exp(-(density*z)^2)</span><br><span class="line">    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.x * (coord); unityFogFactor = exp2(-unityFogFactor*unityFogFactor)</span><br><span class="line">#else</span><br><span class="line">    #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = 0.0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define UNITY_CALC_FOG_FACTOR(coord) UNITY_CALC_FOG_FACTOR_RAW(UNITY_Z_0_FAR_FROM_CLIPSPACE(coord))</span><br><span class="line"></span><br><span class="line"> #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><p>可以追溯宏定义的运算 得到 fogCoord值,并在 UNITY_APPLY_FOG(i.fogCoord, col);得到新得col值。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>INSTANCE 和FOG 会在后面补充，这里只记录shader分析的一个过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shader-源码-Unlit-Color&quot;&gt;&lt;a href=&quot;#Shader-源码-Unlit-Color&quot; class=&quot;headerlink&quot; title=&quot;Shader 源码-Unlit-Color&quot;&gt;&lt;/a&gt;Shader 源码-Unlit-Color&lt;/</summary>
      
    
    
    
    <category term="ShaderLab" scheme="https://leolichenxi.github.io/categories/ShaderLab/"/>
    
    
    <category term="builtin_shaders" scheme="https://leolichenxi.github.io/tags/builtin-shaders/"/>
    
  </entry>
  
  <entry>
    <title>AndroidAppBundle</title>
    <link href="https://leolichenxi.github.io/2021/06/14/U3D/aab%E6%89%93%E5%8C%85/"/>
    <id>https://leolichenxi.github.io/2021/06/14/U3D/aab%E6%89%93%E5%8C%85/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:21.602Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/guide/app-bundle/asset-delivery">官方文档</a></p><h2 id="AndroidAppBundle"><a href="#AndroidAppBundle" class="headerlink" title="AndroidAppBundle"></a>AndroidAppBundle</h2><blockquote><p>googlePlay上一种新的上传格式，以前是传apk,现在可以传Bundle。google play通过dynamic Delevery从Bundle中现在特定的配置给用户。</p></blockquote><h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><p>Play Asset Delivery (PAD) 将 app bundle 的优势带到游戏中。它允许超过 150 MB 的游戏替换旧版扩展文件 (OBB)，方法是将包含游戏所需的所有资源的单个工件发布到 Play。PAD 提供了灵活的分发模式、自动更新、压缩和增量修补功能，并且可免费使用。使用 PAD，所有资源包均在 Google Play 上托管和提供，因此您无需使用内容分发网络 (CDN) 向玩家提供游戏资源。</p><p>Play Asset Delivery 使用资源包，资源包由资源（如纹理、着色器和声音）组成，但不包含可执行代码。通过 Dynamic Delivery，您可以按照以下三种分发模式自定义如何以及何时将各个资源包下载到设备上：安装时分发、快速跟进式分发和按需分发。</p><h4 id="install-time"><a href="#install-time" class="headerlink" title="install-time"></a>install-time</h4><p>资源包在用户安装应用时分发。这些资源包以拆分 APK（APK 集的一部分）的形式提供。它们也称为“预先”资源包；您可以在应用启动时立即使用这些资源包。这些资源包会增加 Google Play 商店上列出的应用大小。用户无法修改或删除这些资源包。</p><h4 id="fast-follow"><a href="#fast-follow" class="headerlink" title="fast-follow"></a>fast-follow</h4><p>资源包会在用户安装应用后立即自动下载；用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。这些资源包会增加 Google Play 商店上列出的应用大小。</p><h4 id="on-demand"><a href="#on-demand" class="headerlink" title="on-demand"></a>on-demand</h4><p>资源包会在应用运行时下载。</p><p>Google Play 商店会以归档文件（而非拆分 APK）的形式提供配置为 fast-follow 和 on-demand 的资源包。这些资源包随后会在应用的内部存储空间中展开。您可以使用 Play Core API 查询以这种方式提供的资源包的位置。应用无法假设这些文件的存在或其位置，因为它们可能会被用户删除，或由 Play Core SDK 在游戏会话之间移动。尽管这些文件可由应用写入，您也应将其视为只读文件，因为资源包补丁程序依赖于这些文件的完整性。</p><p>每个 fast-follow 和 on-demand Asset Pack 的下载大小上限为 512 MB。<br>所有 install-time Asset Pack 的总下载大小上限为 1 GB。<br>一个 Android App Bundle 中的所有 Asset Pack 的总下载大小上限为 2 GB。<br>一个 Android App Bundle 中最多可以使用 50 个资源包。</p><p>也就是从install-time 我们可以放比较多的重要资源</p><p>fast-follow 和 on-demand 放二级资源</p><p>我们项目目前有将近4G 的资源 最新的assetbundle（3.75G）</p><p>从PAD中可以处理将近2G的资源，仍需有将近2G的资源从cdn下载。</p><h3 id="PAD需要处理的工作"><a href="#PAD需要处理的工作" class="headerlink" title="PAD需要处理的工作"></a>PAD需要处理的工作</h3><ol><li>打包时记录所有的AssetPack信息, 测试分支已经写好。（每个pack的文件和大小信息等。）加入自动打包也已改好。</li><li>根据记录的pack信息 在应用启动时对PAD做资源完整检查;</li><li>每个分包的PlayAssetPack的处理（分包里的assetbundle 或其它资源，需要先加载此AssetPack 再从assetPack里加载assetbundle）这里包含任何分发模式的资源。</li><li>加载AssetBundle的逻辑修改这里主要是是 以及AssetPack在内存中的依赖维护。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//异步加载</span><br><span class="line">PlayAssetPackRequest playAssetPackRequest = PlayAssetDelivery.RetrieveAssetPackAsync(packName);</span><br><span class="line"> //异步加载</span><br><span class="line">AssetBundleCreateRequest request = playAssetPackRequest.LoadAssetBundleAsync(abPath)</span><br><span class="line"></span><br><span class="line">//目前的加assetbundle     </span><br><span class="line">AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(AssetBundleFullPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在-Play-上测试-app-bundle"><a href="#在-Play-上测试-app-bundle" class="headerlink" title="在 Play 上测试 app bundle"></a>在 Play 上测试 app bundle</h3><p><a href="https://developer.android.com/guide/app-bundle/test">https://developer.android.com/guide/app-bundle/test</a></p><h3 id="本地测试流程"><a href="#本地测试流程" class="headerlink" title="本地测试流程"></a>本地测试流程</h3><p><a href="https://developer.android.com/guide/app-bundle/test">官方测试参考文档</a></p><p><a href="https://github.com/google/bundletool/releases">下载BundleTool</a></p><p>将aab装成课本第测试的apks 此步骤以自动加入到打包流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundletool build-apks --local-testing</span><br><span class="line">  --bundle my_app.aab</span><br><span class="line">  --output my_app.apks</span><br></pre></td></tr></table></figure><p>安装到测试机(模拟器需要abd 先链接模拟器，比如夜神模拟器：adb connect 127.0.0.1:62001)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundletool install-apks --apks my_app.apks</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/app-bundle/asset-delivery&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;AndroidAppBundle&quot;&gt;&lt;a href=&quot;#AndroidAppBundle</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="AAB" scheme="https://leolichenxi.github.io/tags/AAB/"/>
    
  </entry>
  
  <entry>
    <title>优化记录 - 1</title>
    <link href="https://leolichenxi.github.io/2021/06/14/U3D/%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2021/06/14/U3D/%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:24.638Z</updated>
    
    <content type="html"><![CDATA[<p>优化的最终是希望代码占用内存小的同时执行效率高。</p><p>unity 分为CPU 和 GPU 优化</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;优化的最终是希望代码占用内存小的同时执行效率高。&lt;/p&gt;
&lt;p&gt;unity 分为CPU 和 GPU 优化&lt;/p&gt;
&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h1&gt;&lt;h1 id=&quot;G</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="优化" scheme="https://leolichenxi.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Audio</title>
    <link href="https://leolichenxi.github.io/2021/06/14/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/audio%E4%BC%98%E5%8C%96/"/>
    <id>https://leolichenxi.github.io/2021/06/14/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/audio%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-14T04:00:00.000Z</published>
    <updated>2022-02-21T11:07:47.100Z</updated>
    
    <content type="html"><![CDATA[<p>导入前的声音格式选择</p><pre><code> 短声音：.aifff和.wav长声音：.mp3和.ogg</code></pre><p>导入后的声音格式选择</p><pre><code> Force ToMono：如果启用，该音频将向下混合到单声道Load In Backgroud: 加载将在一个单独的线程上延迟的时间发生，而不会阻塞主线程Ambisonic: 如果音频文件包含有双声编码的音频，那么启用这个选项 LoadType: ①Decompress On Load:处理较小的声音（load就解压）                  ②Compressed In Memory：较大的声音（保持解压的状态）                  ③Streaming：使用最少的内存来缓冲压缩数据（很长的音乐）</code></pre><p> Compression Format：</p><pre><code>                 ①PCM  非常短的音效是最好的，质量高，文件大                 ②ADPCM大量噪音的声音，需要大量播放，比如脚步声，武器                 ③Vorbis/MP3 质量低，中等长度背景音乐                 ④HEVAG 类似于adpcm</code></pre><p>Preload Audio Data 预加载</p><p>方案：大点的音频: Streaming,不预加载，Vorbis</p><pre><code> 小点的音频DecompressOnLoad 不预加载  ，Vorbis</code></pre><p>会优化比较适中的cpu和内存，具体还要根据项目实际确定</p><h1 id="Unity性能优化-音频设置"><a href="#Unity性能优化-音频设置" class="headerlink" title="Unity性能优化-音频设置"></a>Unity性能优化-音频设置</h1><p>没想到Unity的音频会成为内存杀手，在实际的商业项目中，音频的优化必不可少。</p><ol><li><p>Unity支持许多不同的音频格式，但最终它将它们全部转换为首选格式。音频压缩格式有PCM、ADPCM、Vorbis，不是所有平台都支持这些所有的压缩格式，有些平台，例如WebGL只支持AAC格式。</p></li><li><p>所有音频导入时，默认两项设置，LoadType是”Decompress On Load”，压缩格式是“Vorbis”，例如下图原始文件大小计算为35.9 MB，导入的大小计算为10.7 MB。这意味着这个音频剪辑将使您的游戏（存档）大小增加10兆字节，但播放它需要近36兆字节的RAM。</p></li></ol><p>These are default import settings.</p><ol start="3"><li>Load Type的各个选项</li></ol><p>Compressed In Memory – 音频剪辑将存储在RAM中，播放时将解压缩，播放时不需要额外的存储。<br>Streaming –音频永久存在设备上(硬盘或闪存上) ，播放流媒体方式. 不需要RAM进行存储或播放。<br>Decompress On Load – 未压缩的音频将存储在RAM中。这个选项需要的内存最多，但是播放它不会像其他选项那样需要太多的CPU电源。<br>         怎么选？长音频播放消耗大量内存，如果播放时不想在内存中进行解压，有两个选择：</p><pre><code>     （1）Load Type选“Streaming”， Compression Format 选”Vorbis&quot;，使用最少的内存，但需要更多的CPU电量和硬盘I/O操作；     （2）Load Type选“Compressed In Memory”， Compression Format 选”Vorbis&quot;，磁盘I/O操作被替换成内存的消耗，请注意，要调整“Quaility”滑块以减小压缩剪辑的大小，以交换音质，一般推荐70%左右。         一般是看到底音乐占据多少内存以及你的目标机型是什么样子的，如果音乐占据的内存本身比较高，你的目标机型的内存又比较小，那么就选择第二种，这种方案会卡一点，否则选择第一种就更好</code></pre><ol start="4"><li><p>声音特效</p><p>  （1）对于经常播放的和短的音频剪辑，使用“Decompress On Load”和“PCM或ADPCM”压缩格式。当选择PCM时，不需要解压缩，如果音频剪辑很短，它将很快加载。你也可以使用ADPCM。它需要解压，但解压比Vorbis快得多。</p><p>   （2）对于经常播放，中等大小的音频剪辑使用”Compressed In Memory“和”ADPCM“压缩格式，比原始PCM小3.5倍，解压算法的CPU消耗量不会像vorbis消耗那么多CPU。</p><p>   （3）对于很少播放并且长度比较短的声音剪辑，使用”Compressed In Memory”, ADPCM 这种压缩格式,原因同（2）。</p><p>  （4）对于很少播放中等大小的音频，使用”Compressed In Memory“ 和Vorbis压缩格式。这个音频可能太长，无法使用adpcm存储，播放太少，因此解压缩所需的额外CPU电量不会太多。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;导入前的声音格式选择&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 短声音：.aifff和.wav

长声音：.mp3和.ogg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入后的声音格式选择&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Force ToMono：如果启用，该音频将向下混合到单声道

Loa</summary>
      
    
    
    
    <category term="U3D" scheme="https://leolichenxi.github.io/categories/U3D/"/>
    
    
    <category term="资源" scheme="https://leolichenxi.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
</feed>
