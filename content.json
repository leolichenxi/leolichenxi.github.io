{"meta":{"title":"CXGame","subtitle":"","description":"","author":"李晨曦","url":"https://leolichenxi.github.io","root":"/"},"pages":[{"title":"links","date":"2021-06-11T10:32:13.000Z","updated":"2021-06-11T10:41:29.750Z","comments":true,"path":"Links/index.html","permalink":"https://leolichenxi.github.io/Links/index.html","excerpt":"","text":""},{"title":"我的博客","date":"2021-06-11T10:32:13.000Z","updated":"2023-01-05T07:01:29.397Z","comments":true,"path":"about/index.html","permalink":"https://leolichenxi.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-06-11T10:32:13.000Z","updated":"2023-01-05T07:01:29.397Z","comments":true,"path":"categories/index.html","permalink":"https://leolichenxi.github.io/categories/index.html","excerpt":"","text":""},{"title":"repository","date":"2021-06-11T10:32:13.000Z","updated":"2021-06-11T15:42:43.015Z","comments":true,"path":"repository/index.html","permalink":"https://leolichenxi.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-11T10:32:12.000Z","updated":"2023-01-05T07:01:29.403Z","comments":true,"path":"tags/index.html","permalink":"https://leolichenxi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JetBrains","slug":"Tools/JetBrains设置","date":"2023-12-22T04:00:00.000Z","updated":"2023-12-22T06:42:15.269Z","comments":true,"path":"2023/12/22/Tools/JetBrains设置/","link":"","permalink":"https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"作为JetBrains系列深度依赖用户者,备注一下使用 设置缓存设置安装得.exe 一般有个 .properties 尾缀，修改配置自己设置的缓存路径 123456789# Uncomment this option if you want to customize a path to the settings directory.#---------------------------------------------------------------------idea.config.path=D:\\Caches\\JetBrains/.IdeaIC/config#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the caches directory.#---------------------------------------------------------------------idea.system.path=D:\\Caches\\JetBrains/.IdeaIC/system 换行设置默认宽度 12 可设置 关闭自动更新","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://leolichenxi.github.io/tags/JetBrains/"}]},{"title":"VSCode","slug":"Tools/vscode快捷键","date":"2023-12-22T04:00:00.000Z","updated":"2023-12-22T06:32:32.545Z","comments":true,"path":"2023/12/22/Tools/vscode快捷键/","link":"","permalink":"https://leolichenxi.github.io/2023/12/22/Tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf##Window ##Mac","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://leolichenxi.github.io/tags/VSCode/"}]},{"title":"JetBrains","slug":"Tools/JetBrains快捷键","date":"2023-12-22T04:00:00.000Z","updated":"2023-12-22T06:36:53.920Z","comments":true,"path":"2023/12/22/Tools/JetBrains快捷键/","link":"","permalink":"https://leolichenxi.github.io/2023/12/22/Tools/JetBrains%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"==Ctrl== Ctrl + A 全选Ctrl + B 快速打开光标处的类或方法(等同于 Ctrl + 鼠标点击)Ctrl + C 复制（不选定内容的话默认会复制光标所在整行）Ctrl + D 复制行或是块（不选定内容的话默认复制当前行到下一行）Ctrl + E 最近打开的文件Ctrl + F 当前代码中查找Ctrl + G 跳到指定行Ctrl + H 显示类层次图Ctrl + J 自动代码提示（提示的是自己定义的代码格式）Ctrl + K git 或 VCS 提交项目Ctrl + L 查看变量的下一个位置（需要先 Ctrl + F 激活查找）Ctrl + M 将光标所在的行移到屏幕中间（连同光标一块移动到屏幕中间）Ctrl + N 查找类Ctrl + O 选择可覆盖/继承的方法Ctrl + P 方法参数提示显示（只显示入参的）Ctrl + Q 鼠标放在变量/类名/方法名等上面（也可以在提示补充的时候按），显示文档内容。（入参，返回值，所属模块等） 同类似的功能还有一个 Ctrl + Shift + I，直接显示函数定义处的内容（所以 Ctrl + P，Ctrl + Q 和 Ctrl + Shift + I 的查看是一个渐进详细的过程）Ctrl + R 替换Ctrl + S 保存Ctrl + T git 或 VCS 更新项目Ctrl + U 前往父类的方法/父类Ctrl + V 粘贴Ctrl + W 选中光标所在的单词 ，连续按会有其他效果 (相反的是Ctrl+Shift+W)ctrl + X 剪切行Ctrl + Y 删除行Ctrl + Z 撤销 Ctrl + F1 显示错误Ctrl + F3 调转到所选中的词的下一个同名位置Ctrl + F7 Find Usages in File（可以同时查找多个变量）Ctrl + F8 打开或关闭行断点Ctrl + F9 编译Ctrl + F11 弹出一个小框来指定式添加书签(可以对文件或文件夹起作用)Ctrl + F12 当前编辑的文件中快速导航(可以直接键入字母，会筛选你输入的来匹配对应是否有的方法，来快速定位)(类似结构图)Ctrl + Tab 编辑窗口切换 (如果在切换的过程又加按上 delete,则是关闭对应选中的窗口)Ctrl + delete 删除光标后面的单词（delete 只是删除单个字符哟！）Ctrl + home/end 跳到文件头文件尾Ctrl + BackSpace 删除光标前面的单词Ctrl + [ 或 ] 移动光标到块的初/末括号地方Ctrl + / 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl + 1，2，3，4…. 快速定位到书签代码处(必须先 Ctrl + Shift + 1,2,3,4…添加书签Ctrl + 小键盘+/- 折叠/展开代码Ctrl + 鼠标单击编辑窗口的文件标题 弹出该文件路径,可以通过这个打开文件所在地方(相当于Ctrl + Alt + F12)Ctrl + ← 或 → 光标跳到上/下个单词Ctrl + ↑ 或 ↓ 相当于你用鼠标滑滚轮(为了方便鼠标党)Ctrl + ` 快速切换常用设置 ==Alt== Alt + 1 切换到 Project 模块Alt + 2 切换到 Favorites 模块Alt + 3 切换到 Find 模块Alt + 4 切换到 Run 模块Alt + 5 切换到 Debug 模块Alt + 6 切换到 Problems 模块Alt + 7 切换到 Structure 模块Alt + 8 切换到 Services 模块Alt + 9 切换到 Git 模块Alt + Q Context Info（上下文信息，可以快速帮你定位当前位置的上下文）Alt + F1 弹出文件选择目标，这个很好用的Alt + F2 多个浏览器预览Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示（类似于 Ctrl + C， Ctrl + F）。Alt + F4 关闭软件Alt + F7 查看该方法/变量/类被调用的地方Alt + F8 在debug 的状态下，选中某些变量或是对象，按此快捷键弹出可输入变量、方法的调试框，指定查看该内容的 debug 情况Alt + F12 进入终端Alt + Home 跳到文件导航barAlt + Insert 生成代码(如 get,set 方法,构造函数等)Alt + ← 或 → 切换当前打开的代码文件视图Alt + ↑ 或 ↓ 在方法间快速移动定位Alt + Enter 快速修复(可以用来导入单个包)Alt + ` VCS快捷选项 ==Shift== Shift + F6 重构：重新命名Shift + F9 debug 当前程序，相当于点击 debug 按钮Shift + F10 Run(运行)当前程序，相当于点击 run 按钮Shift + F11 查看书签Shift + end 选中从光标到end 处Shift + home 选中从光标到 home 处Shift + Enter 光标所在行下空出一行，光标跳下Shift + 单击 可以关闭文件Shift + 滚轮 横向滚动轴滚动(非常强大，现在好多文本编辑器都默认有这个功能了) ==Ctrl+Alt== Ctrl + Alt + A git add (需要先配置 git)Ctrl + Alt + B 跳到具体的实现方法，查找接口/抽象方法的具体实现很好用(相反行为的快捷键是Ctrl+b)Ctrl + Alt + C 快速引进一个常量Ctrl + Alt + F 快速引进一个实例变量Ctrl + Alt + I 选中部分自动缩进行（有点类似格式化，但是只是整理行格式而已）Ctrl + Alt + L 格式化代码Ctrl + Alt + M 方法抽取/重构Ctrl + Alt + N 将方法内联化Ctrl + Alt + O 优化导入的类和包Ctrl + Alt + P 参数抽取Ctrl + Alt + S 快速打开设置 SettingsCtrl + Alt + T 选中的地方代码环绕提示 例如 ：try/catch 选中的一块代码Ctrl + Alt + V 快速引进一个变量名Ctrl + Alt + W 关闭所有编辑的快捷键（自己添加，再 close all）Ctrl + Alt + Y 从磁盘重载Ctrl + Alt + Z git rollback (需要先配置 git)Ctrl + Alt + F5 Attach to ProcessCtrl + Alt + F7 寻找被该类或是变量被使用的地方，用弹出框的方式找出来，，也类似于 Ctrl + 鼠标 左击。跟 Alt+F7 效果一样，但是因为是弹出框，选中了一个位置就会消失。Ctrl + Alt + F12 文件路径Ctrl + Alt + Enter 光标所在行上空出一行，光标跳上Ctrl + Alt + home 弹出跟当前文件有关联的文件目录(比如jsp 里面有导入几个js 和 css,这些文件就是关联文件)Ctrl + Alt + ← 或 → 退回/前进到上一个操作的地方Ctrl + Alt + ↑ 或 ↓ 在 Find 模式下，挑到上/下个查找的文件Ctrl + Alt + 空格 类名或接口名提示(可能会和输入法快捷键冲突) ==Ctrl+Shift== Ctrl + Shift + A Find ActionCtrl + Shift + B 变量类型声明Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板Ctrl + Shift + E 最近更改的文件Ctrl + Shift + F 全局查找文件（通过某个词，指定要搜索的文件类型，目录。注意：这个也可能会和 Windows 的简繁切换快捷键相冲突哟！！！）Ctrl + Shift + I 在方法名或是类名下，按此快捷键显示该方法或是类的源码结构，无需点击进去查看源码（当然了，必须是你已经导入源码的情况下才看得到）Ctrl + Shift + J 自动将下一行合并到当前行末尾Ctrl + Shift + K git pushCtrl + Shift + M 光标位置在括号前后切换Ctrl + Shift + N 通过输入文件名和行号（可以输入部分名称，支持模糊）来定位查找文件Double + Shift (快速双击 Shift)搜索最近打开的文件，我也是经常误触才发现他这个功能Ctrl + Shift + P 表达式的类型信息Ctrl + Shift + R 搜索指定范围文件，替换文字Ctrl + Shift + T 如果在常规类下按它，弹出已写好的，可选择的对应 Test 类，如果在该 Test 类下按它，则直接回到源类。Ctrl + Shift + U // 大/小写都是这个快捷键Ctrl + Shift + V 粘贴最近复制过的一些信息（从历史记录粘贴）Ctrl + Shift + W Ctrl + W 的逆向操作Ctrl + Shift + Y Code With MeCtrl + Shift + Z 取消撤销（恢复上一次操作）Ctrl + Shift + F7 高亮显示所有该选中文本，按 Esc 高亮消失。Ctrl + Shift + F8 查看断点Ctrl + Shift + F12 编辑器全屏Ctrl + Shift + Del 删除环绕的标签Ctrl + Shift + 1，2，3… 快速添加书签Ctrl + Shift + Space 自动补全代码（智能提示）Ctrl + Shift + Enter 自动给末尾加;完成代码Ctrl + Shift + ↑ 或 ↓ 移动光标所在 statement 域移动到上/下 (Alt + Shift + ↑ 或 ↓ 移动光标所在行到上/下)Ctrl + Shift + [ 或 ] 选中从光标所在位置到它的父级区域(界面上层导航可能更开)Ctrl + Shift + 小键盘 + 或 – 折叠/展开所有代码Ctrl + Shift + ← 或 → 选中临边左/右的单词或是符号Ctrl + Shift + / 块注释（使用 =begin block =end 进行注释）Ctrl + Shift + Backspace(退格) 回到上次修改的地方(跟 Ctrl+Alt+左右方向键不一样的地方是，只回退到修改的地方，而不是过去光标放的地方) ==Alt+Shift== Alt + Shfit + B 查看当前行对应的 commit 提交记录详情Alt + Shift + C 查看最近操作项目的变化情况列表(在版本控制下，显示比较缓慢)Alt + Shift + F 添加到收藏夹Alt + Shift + G 进入多行选取模式并将光标放在所选行的末尾(简单理解就是，选中多行之后使用这个快捷键，你可以同时往这多行末尾添加相同的内容，感觉和列模式有些像，但列模式不同行的光标都在同一列，这块不同行的光标可以不在同一列 —— 都在各自行的末尾)Alt + Shift + J 取消选中（有点像 Ctrl + Alt + Shift + J 的逆操作，不过 Alt + Shift + J 每次只取消选中一个地方）Alt + Shift + L 加载上下文Alt + Shift + N 添加任务Alt + Shift + S 保存上下文Alt + Shift + T 切换任务Alt + Shift + U 驼峰命名法和蛇形命名法切换(需要先选中方法名对应的字符串)Alt + Shift + W 关闭活跃任务Alt + Shift + X 清理上下文Alt + Shift + F9 弹出debug 运行菜单，提供选择性debug 哪个(这个需要自己尝试下，按后会有弹出框，记得查看)Alt + Shift + F10 弹出run 菜单，提供选择性run 哪个(这个需要自己尝试下，按后会有弹出框，记得查看)Alt + Shift + ↑ 或 ↓ 移动光标所在行到上/下Alt + Shift + Insert 切换到列选择模式（再次可切换回行选择模式）Alt + Shift + 鼠标左键单击不放,拖动 可以直接方块区域选择（也叫列选或块选，批量修改列的时候很有用） ==Ctrl+Alt+Shift== （用得不多，因为总感觉手指头不太够用） Ctrl + Alt + Shift + C 复制参考信息(方法的继承关系，或文件相对路径及当前所在行号)Ctrl + Alt + Shift + D 以 UML 的形式显示改动Ctrl + Alt + Shift + L 格式化文件Ctrl + Alt + Shift + J 选中所有用到当前方法的地方（这个用来统一修改函数名和调用点函数名之类的很有用，就不用单独一个个去修改了）Ctrl + Alt + Shift + N 查找类中的方法或变量Ctrl + Alt + Shift + T 选择重构方式Ctrl + Alt + Shift + V 不带格式的简单黏贴Ctrl + Alt + Shift + X Deployment -&gt; Upload to (上传文件改动到指定服务器，对于将本地文件改动快速同步到远端服务器的时候很好用)Ctrl + Alt + Shift + F7 Find Usages SettingsCtrl + Alt + Shift + F8 添加临时行断点","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://leolichenxi.github.io/tags/JetBrains/"}]},{"title":"adb常用命令记录","slug":"Shell/adb","date":"2023-12-22T04:00:00.000Z","updated":"2023-12-22T07:35:07.148Z","comments":true,"path":"2023/12/22/Shell/adb/","link":"","permalink":"https://leolichenxi.github.io/2023/12/22/Shell/adb/","excerpt":"","text":"常用命令 指令 作用 eg adb devices 查看连接设备 adb install apk路径 安装应用 adb install test.apk adb install -r apk路径 安装apk 到sd 卡 adb install -r demo.apk adb uninstall 包名 卸载应用，需要指定包 adb uninstall cn.com.test.mobile adb uninstall -k 包名 卸载app 但保留数据和缓存文件 adb uninstall -k cn.com.test.mobile adb shell pm list packages 列出手机装的所有app 的包名 adb shell pm list packages -3 列出除了系统应用的第三方应用包名 adb shell pm clear cn.com.test.mobile 清除应用数据与缓存 adb shell am start -ncn.com.test.mobile/.ui.SplashActivity 启动应用 adb shell dumpsys package 包信息Package Information adb shell dumpsys meminfo 内存使用情况Memory Usage adb shell am force-stop cn.com.test.mobile 强制停止应用 adb logcat 查看日志 adb logcat -c 清除log 缓存 adb reboot 重启 adb get-serialno 获取序列号 adb shell getprop ro.build.version.release 查看Android 系统版本 adb shell top -s 10 查看占用内存前10 的app adb push 从本地复制文件到设备 adb pull 从设备复制文件到本地 adb bugreport 查看bug 报告 adb shell dumpsys battery 手机电量信息 adb logcat -v time &gt; D:\\logs\\logcat.log 输出实时日志并保存在本地文件，通过Ctrl+C来停止。抓取日志的步骤：先输入命令启动日志，然后操作App，复现bug，再ctrl+c停止日志，分析本地保存的文件 系统操作指令 指令 作用 eg adb shell getprop ro.product.model 获取设备型号 adb shell getprop ro.build.version.release 获取设备android系统版本 adb get-serialno 获取设备的序列号（设备号） adb shell wm size 获取设备屏幕分辨率 adb shell screencap -p /sdcard/mms.png 屏幕截图 adb pull /sdcard/mms.png D:\\app 将截图导出到本地 adb shell dumpsys activity 获取当前 Android 系统 Activity 栈中 Activity 信息 adb shell dumpsys activity top 获取当前 Android 系统 中与用户交互的 Activity 的详细信息 adb shell dumpsys meminfo [应用包名] 查看应用的内存使用情况 adb shell dumpsys package [应用报名] 获取手机里面某个 apk 的应用信息、版本信息 adb shell dumpsys activity activities 显示当前所有在运行的任务栈，并可查看栈中所有的 Activity 的列表 连接设备adb [-d-e-s ] 连接指定设备参数： -d 指定当前唯一通过USB 连接的Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s 指定相应serialNumber 号的设备/模拟器为命令目标 command 为所需对设备执行的命令 eg: 123456$adb devicesList of devices attachedcf263b7f deviceemulator-5554 offline192.168.1.6:5555 device$adb -s cf263b7f #连接cf264b8f 设备 adb devices 查看已连接的设备信息, 上面已经连接3台设备。 adb logcatadb logcat在终端窗口中，按下 Ctrl + C（Windows/Linux）或 Command + C（Mac），这会中断正在运行的命令，包括 adb logcat。 保存到文件adb logcat &gt; logcat.txt将设备的日志输出保存到指定的文件（logcat.txt）。这会将所有的日志信息写入文件。 过滤保存adb logcat -s TAG &gt; logcat.txt过滤保存，只保存特定 TAG 的日志信息。 限制保存行数adb logcat -t 1000 &gt; logcat.txt限制保存的行数，上述例子保存最新的1000行日志。 指定时间范围adb logcat -v time -d -t ‘2023-01-01 00:00:00’ &gt; logcat.txt通过 -t 参数指定保存日志的时间范围，上述例子保存从指定时间到现在的日志。 保存指定级别的日志adb logcat *:E &gt; logcat.txt通过 *:E 过滤保存只包含错误级别的日志。可以使用 *:D（调试）、 *:I（信息）、 *:W（警告）等。 请注意，以上命令中的 logcat.txt 是保存日志的文件名，你可以根据需要自定义文件名和保存路径。 日志等级，优先级从低到高分为以下几种： V——Verbose（最低等级，开发调试中的一些详细信息，仅在开发中使用，不可再发布产品中） D——Debug（调试，用于调试的信息，可以在发布产品中关闭，比较常见） I——info（信息，一般提示性的信息） W——Warning（警告） E——Error（错误，已经出现可影响运行的错误，比如应用crash时输出的日志） 在 E级别中可以搜索这个关键字：fatal exception ANR全名Application Not Responding，也就是应用无响应当操作在一段时间内系统无法处理时，系统层面会弹出ANR对话框 在日志中查询：ANR in 在查到ANR in 之后 上一行会有 设备的shell界面进入adb shell多个设备情况下：adb -s &lt;设备序列号&gt; shell 退出exit adb wifi连接adb connect adb disconnect 127.0.0.1:26944 adb 模拟按键adb 命令代替键盘操作，不同的 keycode 能实现不同的功能adb shell input keyevent https://developer.android.com/reference/android/view/KeyEvent 截屏 adb shell screencap -p /sdcard/sc.png屏幕截图 录屏 adb shell screenrecord /sdcard/filename.mp4录制 mp4 格式的视频保存到 /sdcard","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"adb","slug":"adb","permalink":"https://leolichenxi.github.io/tags/adb/"}]},{"title":"","slug":"U3D/VertexStreamSplitting","date":"2023-08-17T03:57:38.904Z","updated":"2023-08-17T03:59:39.272Z","comments":true,"path":"2023/08/17/U3D/VertexStreamSplitting/","link":"","permalink":"https://leolichenxi.github.io/2023/08/17/U3D/VertexStreamSplitting/","excerpt":"","text":"关于使用VertexStreamSplitting优化带宽方案介绍Tile-based GPUs create a shader that calculates the normalized device coordinates based on the provided vertex shader to do binning. It is executed first on every vertex in the scene, whether visible or not. Keeping vertex position data contiguous in memory is therefore a big plus. Other places this vertex stream layout can be beneficial is for shadow passes, as usually you only need position data for shadow calculations, as well as depth prepasses, which is a technique usually used for console/desktop rendering; this vertex stream layout can be a win for multiple classes of the rendering engine!Stream Splitting involves setting up the vertex buffer with a contiguous section of vertex position data and another section containing interleaved vertex attributes. Most applications usually set up their buffers fully interleaving all attributes. This visual explains the difference: Looking at how the GPU fetches vertex data helps us understand the benefits of stream splitting. Assuming for the sake of argument:●32 byte cache lines (a pretty common size)●Vertex format consisting of:Position, vec3 = 12 bytes○Normal vec3 = 12 bytes○UV coordinates vec2 = 8 bytes○Total size = 32 bytesWhen the GPU fetches data from memory for binning, it will pull a 32-byte cache line to operate on. Without vertex stream splitting, it will only actually use the first 12 bytes of this cache line for binning, and discard the other 20 bytes as it fetches the next vertex. With vertex stream splitting, the vertex positions will be contiguous in memory, so when that 32-byte chunk is pulled into cache, it will actually contain 2 whole vertex positions to operate on before having to go back to main memory to fetch more, a 2x improvement!Now, if we combine the vertex stream splitting with vertex compression, we will reduce the size of a single vertex position down to 6 bytes, so a single 32-byte cache line pulled from system memory will have 5 whole vertex positions to operate on, a 5x improvement!原文链接 https://developer.android.com/games/optimize/vertex-data-management#vertex_stream_splitting 摘要：更改顶点缓存布局，将Position与其他的顶点属性分开处理，使Position属性的内存分布变得连续，从而提高cache命中率，降低带宽与性能开销，配合Vertex Compression 使用，效率会更高 unity当中实现也比较简单，将顶点属性分配到不同的stream中，unity支持4个stream，我们这边用2个就可以了，在工具导出fbx的mesh时为新生成的mesh设置下即可 测试数据Device：黑鲨 3Pro GPU:Adreno (TM) 650测试环境：一定数量的玩家主城白模，顶点数约 45w FPS：30 Bandwidth(Bytes/Second) Original Mesh：R + W ≈ 1.75gVertex Stream Splitting Mesh：R + W ≈ 1.35g带宽降低约400M，主要来自Read带宽 VertexMemoryRead(Bytes/Second) VertexMemoryRead相差约400M， 对比上一条，可见降低的Read带宽均为VertexMemory Avg(% Stalled on System Memory) 可以看到StalledOnSystemMemory的百分比下降明显，原因是cache命中率的提高，大大降低了system memory的读取 附录 123456789101112131415161718192021private static readonly VertexAttributeDescriptor[] vertexAttributeDescriptorList = new[]&#123; new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3,0), new VertexAttributeDescriptor(VertexAttribute.Normal, VertexAttributeFormat.Float32, 3,1), new VertexAttributeDescriptor(VertexAttribute.Tangent, VertexAttributeFormat.Float32, 4,1), new VertexAttributeDescriptor(VertexAttribute.Color, VertexAttributeFormat.Float32, 4,1), new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2,1), new VertexAttributeDescriptor(VertexAttribute.TexCoord1, VertexAttributeFormat.Float32, 2,1), new VertexAttributeDescriptor(VertexAttribute.TexCoord2, VertexAttributeFormat.Float32, 4,1) &#125;; private static Mesh CreateMeshFrom(Mesh mesh) &#123; Mesh mesh1 = Object.Instantiate(mesh); //顶点属性分流 //设置顶点属性 int vertexCount = mesh.vertexCount; mesh1.SetVertexBufferParams(vertexCount,vertexAttributeDescriptorList); return mesh1; &#125;","categories":[],"tags":[]},{"title":"","slug":"U3D/DrawIntstance/DrawInstance记录","date":"2023-05-22T02:44:08.466Z","updated":"2023-05-22T02:44:45.878Z","comments":true,"path":"2023/05/22/U3D/DrawIntstance/DrawInstance记录/","link":"","permalink":"https://leolichenxi.github.io/2023/05/22/U3D/DrawIntstance/DrawInstance%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Graphics.DrawMeshInstancedGraphics.DrawMeshInstancedIndirect","categories":[],"tags":[]},{"title":"","slug":"U3D/ECS/Unity性能优化","date":"2023-03-21T02:33:11.168Z","updated":"2023-03-27T08:30:12.804Z","comments":true,"path":"2023/03/21/U3D/ECS/Unity性能优化/","link":"","permalink":"https://leolichenxi.github.io/2023/03/21/U3D/ECS/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"性能优化理解篇一般游戏的性能指标有:帧率、稳定性、流畅性、加载时间(loading)、内存占用、安装包大小、网络延迟、耗电量等。 帧率-流畅性FPS低：基本每一帧耗时都较长卡顿： 某一帧或几帧耗时较高","categories":[],"tags":[]},{"title":"","slug":"U3D/ECS/SLG大世界优化","date":"2023-03-21T02:32:40.624Z","updated":"2023-03-21T06:05:00.684Z","comments":true,"path":"2023/03/21/U3D/ECS/SLG大世界优化/","link":"","permalink":"https://leolichenxi.github.io/2023/03/21/U3D/ECS/SLG%E5%A4%A7%E4%B8%96%E7%95%8C%E4%BC%98%E5%8C%96/","excerpt":"","text":"SLG大世界方案[toc] 基本方案选型","categories":[],"tags":[]},{"title":"","slug":"性能优化/性能篇","date":"2023-01-05T07:33:05.754Z","updated":"2023-01-05T07:33:07.377Z","comments":true,"path":"2023/01/05/性能优化/性能篇/","link":"","permalink":"https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%AF%87/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"性能优化/内存篇-安卓","date":"2023-01-05T07:32:49.724Z","updated":"2023-01-05T08:08:01.552Z","comments":true,"path":"2023/01/05/性能优化/内存篇-安卓/","link":"","permalink":"https://leolichenxi.github.io/2023/01/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E7%AF%87-%E5%AE%89%E5%8D%93/","excerpt":"","text":"内存内存(Memory)是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。 CPU只能访问其寄存器（Register）和内存（Memory）， 无法直接访问硬盘（Disk）。 存储在硬盘上的数据必须首先传输到内存中才能被CPU访问。从访问速度来看，对寄存器的访问非常快，通常为1纳秒； 对内存的访问相对较慢，通常为100纳秒（使用缓存加速的情况下）；而对硬盘驱动器的访问速度最慢，通常为10毫秒。 当一个程序加载到内存中时，它由四个内存区域组成： 堆栈（Stack）：存储由该程序的每个函数创建的临时变量堆（Heap）：该区域特别适用于动态内存分配数据（Data）：存储该程序的全局变量和静态变量代码（Code）：存储该程序的指令 Android之DalvikDalvik 是 Google 公司自己设计用于 Android 平台的 Java 虚拟机，Android 工程师编写的 Java 或者 Kotlin 代码最终都是在这台虚拟机中被执行的。在 Android 5.0 之前叫作 DVM，5.0 之后改为 ART（Android Runtime）。 在整个 Android 操作系统体系中，ART 位于以下图中红框位置：","categories":[],"tags":[]},{"title":"局部性和缓存命中率","slug":"代码篇/局部性","date":"2022-02-01T05:43:00.000Z","updated":"2022-02-21T11:12:30.961Z","comments":true,"path":"2022/02/01/代码篇/局部性/","link":"","permalink":"https://leolichenxi.github.io/2022/02/01/%E4%BB%A3%E7%A0%81%E7%AF%87/%E5%B1%80%E9%83%A8%E6%80%A7/","excerpt":"","text":"时间局部性空间局部性","categories":[{"name":"Codes","slug":"Codes","permalink":"https://leolichenxi.github.io/categories/Codes/"}],"tags":[{"name":"Codes","slug":"Codes","permalink":"https://leolichenxi.github.io/tags/Codes/"}]},{"title":"","slug":"U3D/资源管理/图片格式优化","date":"2021-11-18T07:20:09.089Z","updated":"2021-11-18T07:23:24.171Z","comments":true,"path":"2021/11/18/U3D/资源管理/图片格式优化/","link":"","permalink":"https://leolichenxi.github.io/2021/11/18/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Unity DOTS","slug":"U3D/ECS/Unity DOTS","date":"2021-08-30T04:00:00.000Z","updated":"2022-02-21T11:07:38.984Z","comments":true,"path":"2021/08/30/U3D/ECS/Unity DOTS/","link":"","permalink":"https://leolichenxi.github.io/2021/08/30/U3D/ECS/Unity%20DOTS/","excerpt":"","text":"Job System官方文档 借助 Unity C# 作业系统，用户可以编写与 Unity 其余部分良好交互的多线程代码，并使编写正确代码变得更加容易。 编写多线程代码可以带来高性能优势，包括显著提高帧率。将 Burst 编译器与 C# 作业配合使用可以提高代码生成质量，还可以大大降低移动设备的电池消耗。 C# 作业系统的一个重要特点是它与 Unity 内部使用的系统（Unity 的原生作业系统）相集成。用户编写的代码与 Unity 共享工作线程。此协作避免了创建超过 CPU 核心数的线程（这种情况会导致争用 CPU 资源） NativeContainer NativeContainer是一种托管值类型，为本机内存提供了一个相对安全的C#封装器。它包含一个指向非托管分配的指针。与Unity C# 作业系统一起使用时，NativeContainer允许Job 访问与主线程共享的数据，而不是使用副本。 NativeList - 可调整大小的 NativeArray。 NativeHashMap - 键/值对。 NativeMultiHashMap - 每个键有多个值。 NativeQueue - 先进先出 (FIFO) 队列。 NativeContainer Allocator 创建 NativeContainer 时，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。因此，可以定制分配以便在每种情况下获得最佳性能。可以使用三种 Allocator 类型进行 NativeContainer 内存分配和释放。在实例化 NativeContainer 时需要指定适当的一种类型。 Allocator.Temp 具有最快的分配速度。此类型适用于寿命为一帧或更短的分配，不应该使用Temp将NativeContainer 分配传递给Job，在方法调用返回之前，还需要调用Dispose方法。 以下错误 不应该使用Temp将NativeContainer 分配传递给Job 12345678910111213141516171819202122public struct JobSum : IJob&#123; public int a; public int b; public NativeArray&lt;int&gt; result; public void Execute() &#123; result[0] = result[0]+ a + b; &#125;&#125; void Test() &#123; JobSum jobSum = new JobSum(); jobSum.a = 1; jobSum.b = 10; NativeArray&lt;int&gt; result = new NativeArray&lt;int&gt;(1, Allocator.Temp ); jobSum.result = result; var handle = jobSum.Schedule(); handle.Complete(); result.Dispose(); &#125; Allocator.TempJob的分配速度比Temp慢，但比Persistent快。此类型适用于寿命为四帧的分配，并具有线程安全性，如果没有在四帧内对其执行Dispose,控制台会输出一条从本机代码生成的警告。大多数小作业都使用这种 NativeContainer 分配类型。 Allocator.Persistent 是最慢的分配，但可以在您所需的任意时间内持续存在，如果有必要，可以在整个应用程序的生命周期内存在。此分配器是直接调用 malloc 的封装器。持续时间较长的作业可以使用这种 NativeContainer 分配类型。在非常注重性能的情况下不应使用 Persistent。","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Android 常见 Crash","slug":"U3D/ECS/AndroidCrash","date":"2021-08-30T04:00:00.000Z","updated":"2023-03-16T03:30:12.855Z","comments":true,"path":"2021/08/30/U3D/ECS/AndroidCrash/","link":"","permalink":"https://leolichenxi.github.io/2021/08/30/U3D/ECS/AndroidCrash/","excerpt":"","text":"Android CrashAndroid官网检测和诊断崩溃问题 Android 6.0的源码剖析理解Android Crash处理流程 unity crash 的快速定位 基本概念： ANR 用户在使用App过程中出现弹框，提示应用无响应，计为一次ANR，ANR仅用于Android平台应用。 Java Crash Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出，Jvm虚拟机退出，系统弹框提醒用户，这个我们可以看log查看报错原因，Crash工具都能捕获到。 Native Crash 那 Native 崩溃一般都是因为Native代码中访问非法地址或者是地址对齐出现问题，再或者是发生程序主动abort，这些都会产生对应的signal信号，导致程序异常退出 SIGSEGV 一般是由于空指针、非法指针造成 SIGABRT 后者主要因为 ANR 和调用abort()退出所导致。 Crash常见原因 OOM 代码层或资源内存泄漏 java.lang.outofmemory GL_OUT_OF_MEMORY vukan out of memory NullPointerException 空指针异常 IndexOutOfBoundsException 数组、集合等越界 java.lang.StackOverflowError 堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误，（死循环了等） ClassCastException 类型转换异常 ActivityNotFoundException Activity未找到异常 SecurityException 安全异常 llegalArgumentException: Service not registered 服务未注册异常 BadTokenException API 平台兼容性Unity 的一些API在不同硬件的兼容性问题 错误符号 SIGSEGV 段错误 SEGV_MAPERR 要访问的地址没有映射到内存空间。 比如上面对空指针的写操作， 当指针被意外复写为一个较小的数值时。 SEGV_ACCERR 访问的地址没有权限。比如试图对代码段进行写操作。 SIGFPE 浮点错误，一般发生在算术运行出错时。 FPE_INTDIV 除以0 FPE_INTOVE 整数溢出 SIGBUS 总线错误BUS_ADRALN 地址对齐出错。arm cpu比x86 cpu 要求更严格的对齐机制，所以在 arm cpu 机器中比较常见。 SIGILL 发生这种错误一般是由于某处内存被意外改写了。 ILL_ILLOPC 非法的指令操作码 ILL_ILLOPN 非法的指令操作数 当调用堆栈中出现 stack_chk_fail 函数时，一般是由于比如 strcpy 之类的函数调用将栈上的内容覆盖，而引起栈检查失败。 分类 一般分为Java Crash 和 Native Crash Native Crash特点 出错时界面不会弹出提示框提醒程序崩溃（Android 5.0以下） 出错时会弹出提示框提醒程序崩溃（Android 5.0以上） 程序会直接闪退到系统桌面 这类错误一般是由C++层代码错误引起的 绝大部分Crash工具不能够捕获 产生原因崩溃分析 堆栈信息查找 log日志，尤其是warning error相关; 机型信息 GPU 内存 系统 厂商 信息等共性信息，(有可能某个厂商特定修改); 复现步骤; 前后台信息; 图形API vukan opengl 版本的bug. 工具addr2line，objdump，ndk-stack等几个工具 crash上报第三方CrashSight Bugly Firebase 问题记录","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://leolichenxi.github.io/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"CSharpLua","slug":"Tools/CSharp.lua","date":"2021-06-17T04:00:00.000Z","updated":"2021-06-17T11:12:00.203Z","comments":true,"path":"2021/06/17/Tools/CSharp.lua/","link":"","permalink":"https://leolichenxi.github.io/2021/06/17/Tools/CSharp.lua/","excerpt":"","text":"CSharpLua一个翻译c#为Lua的工具Git地址Charp.lua 参数1234567891011121314151617181920212223242526D:\\&gt;dotnet CSharp.Lua.Launcher.dll -hUsage: CSharp.lua [-s srcfolder] [-d dstfolder]Arguments-s : can be a directory where all cs files will be compiled, or a list of files, using &#x27;;&#x27; or &#x27;,&#x27; to separate-d : destination directory, will put the out lua filesOptions-h : show the help message and exit-l : libraries referenced, use &#x27;;&#x27; to separate if the librarie is a module, whitch is compield by CSharp.lua with -module arguemnt, the last character needs to be &#x27;!&#x27; in order to mark -m : meta files, like System.xml, use &#x27;;&#x27; to separate-csc : csc.exe command argumnets, use &#x27; &#x27; or &#x27;\\t&#x27; to separate-c : support classic lua version(5.1), default support 5.3-a : attributes need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-a&quot;&quot; only, all attributes whill be exported-e : enums need to export, use &#x27;;&#x27; to separate, if &quot;&quot;-e&quot;&quot; only, all enums will be exported-ei : enums is represented by a variable reference rather than a constant value, need to be used with -e-p : do not use debug.setmetatable, in some Addon/Plugin environment debug object cannot be used-metadata : export all metadata, use @CSharpLua.Metadata annotations for precise control-module : the currently compiled assembly needs to be referenced, it&#x27;s useful for multiple module compiled-inline-property: inline some single-line properties-include : the root directory of the CoreSystem library, adds all the dependencies to a single file named out.lua-noconcurrent : close concurrent compile 编译源码打开 CSharp.lua.sln自己可编译 我这里选择 Release Build 红色标记处为编译成功后 这里新建一个文件夹将上图红色标记文件拷出 cmd测试： dotnet CSharp.lua.Launcher.dll -h 编译c# 工程lua 使用的 5.3 版本 新建 CompileScript Console工程,新增文件夹Core创建测试脚本 Test.cs 123456789101112131415161718192021222324using System;namespace CompileScript.Core&#123; public class Test &#123; public int a; public int b; public Test() &#123; &#125; public void Debug() &#123; Console.WriteLine(a + b); &#125; &#125; &#125; TestClass2.cs 12345678910111213namespace CompileScript.Core&#123; class TestClass2 &#123; public void Debug() &#123; Test t = new Test(); t.Debug(); &#125; &#125;&#125; 命令行： dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export 在Export 下创建lua工程将 copy 到工程，新建main.lua 123456789require(&quot;All&quot;)()require(&quot;manifest&quot;)()local baseTime = System.DateTime(1970, 1, 1)print(baseTime:ToString())local t = CompileScript.Core.Test()t.a = 10t:Debug() 运行 可以 将 copy 到工程，新建main.lua 第三方库引用CompileScript 工程添加Newtonsoft库 1234567891011121314151617181920212223242526using System;using Newtonsoft.Json;namespace CompileScript.Core&#123; public class Test &#123; public int a; public int b; public Test() &#123; &#125; public void Debug() &#123; Console.WriteLine(a + b); Console.WriteLine(JsonConvert.SerializeObject(this)); &#125; &#125; &#125; 编译指令 G:\\Learning\\CsharpLua\\CSharpLuaTools&gt;dotnet CSharp.lua.Launcher.dll -s ../CompileScript/CompileScript/CompileScript/Core -d ../Export -l ../3rd/Newtonsoft.Json.dll 运行代码 报错 这里第三方库dll的实现需要自己适配 这里适配 NewtonsoftJson.JsonConvert.SerializeObject(this) 新建 NewtonsoftJson.lua 12345678Newtonsoft = &#123;&#125;Newtonsoft.Json = &#123;&#125;Newtonsoft.Json.JsonConvert = &#123;&#125;Newtonsoft.Json.JsonConvert.SerializeObject = function (obj) return &quot;todo&quot;endreturn Newtonsoft return “todo”可修改为lua相关的json库，比如cjson 注意事项 第三方库的依赖尽量少依赖 如果有需要查看适配结果，多测试 核心库CoreSystem.Lua 文件夹下的适配了多数System。 Tip如果手写Lua 需要调用翻译的lua class 时，如果不知道如何new对象等，参考TestClass2, 创建一个专门的class 用来测试 翻译出的如何new 对象。 适配踩坑Unity工程适配 ToLua支持，Xlua 实际测试不支持，如果在Xlua 使用，不得依赖UnityEngine 相关库。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"Charp Lua","slug":"Charp-Lua","permalink":"https://leolichenxi.github.io/tags/Charp-Lua/"}]},{"title":"CMake","slug":"Tools/Cmake","date":"2021-06-17T04:00:00.000Z","updated":"2023-06-13T02:38:55.325Z","comments":true,"path":"2021/06/17/Tools/Cmake/","link":"","permalink":"https://leolichenxi.github.io/2021/06/17/Tools/Cmake/","excerpt":"","text":"CMAKE 使用考虑到在项目中定义Native库和编译其它的开源Native库，客户端往往对编译原理计算机基础比较薄弱，记录下CMake使用笔记 主要从官网记录 CMake官网","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://leolichenxi.github.io/tags/CMake/"}]},{"title":"四叉树","slug":"数据结构/四叉树","date":"2021-06-14T04:00:00.000Z","updated":"2021-06-14T05:37:26.823Z","comments":true,"path":"2021/06/14/数据结构/四叉树/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9B%E5%8F%89%E6%A0%91/","excerpt":"","text":"四叉树四叉树Wiki 四叉树是一种树状数据结构，在每一个节点上会有四个子区块。四叉树常应用于二维空间资料的分析与分类。 它将资料区分成为四个象限。资料范围可以是方形或矩形或其他任意形状。这种数据结构是由 拉斐尔·芬科尔(Raphael Finkel) 与 J. L. Bentley 在1974年发展出来 。 类似的资料分割方法也称为 Q-tree。 所有的四叉树法有共同之特点: 可分解成为各自的区块 每个区块都有节点容量。当节点达到最大容量时，节点分裂 树状数据结构依造四叉树法加以区分 根据理论在2D游戏中实际优化到的运用，在几百个单位中搜查，屏幕中的物体代码如下只要点在区域内就可以插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349using System;using System.Collections.Generic;public class TreeRect&#123; public float X &#123; get; private set; &#125; public float Y &#123; get; private set; &#125; public float W &#123; get; private set; &#125; public float H &#123; get; private set; &#125; public float HalfW &#123; get; private set; &#125; public float HalfH &#123; get; private set; &#125; public float XL &#123; get; private set; &#125; public float XR&#123; get; private set; &#125; public float YT &#123; get; private set; &#125; public float YB &#123; get; private set; &#125; /// &lt;summary&gt; /// 点 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; public TreeRect(float x, float y) &#123; SetRect(x, y, 0, 0); &#125; /// &lt;summary&gt; /// 四边形 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;w&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;h&quot;&gt;&lt;/param&gt; public TreeRect(float x, float y, float w, float h) &#123; SetRect(x, y, w, h); &#125; public void SetRect(float x, float y, float w, float h) &#123; X = x; Y = y; W = w; H = h; HalfW = W * 0.5f; HalfH = H * 0.5f; XL = X - HalfW; XR = X + HalfW; YB = Y - HalfH; YT = Y + HalfH; &#125; public bool Intersect(TreeRect other) &#123; return (!(XR &lt; other.XL || XL &gt; other.XR)) &amp;&amp; (!(YT &lt; other.YB || YB &gt; other.YT)); &#125; public bool IsCenterIn(TreeRect other) &#123; return other.X &lt;= XR &amp;&amp; other.X &gt;= XL &amp;&amp; other.Y &lt;= YT &amp;&amp; other.Y &gt;= YB; &#125; public bool IsIn(TreeRect other) &#123; return XR &lt;= other.XR &amp;&amp; XL &gt;= other.XL &amp;&amp; YT &lt;= other.YT &amp;&amp; YB &gt;= other.YB; &#125; public override string ToString() &#123; return $&quot;(&#123;X&#125;,&#123;Y&#125;,&#123;W&#125;,&#123;H&#125;)&quot;; &#125; public static TreeRect operator *(TreeRect rhs,float lhs) &#123; rhs.SetRect(rhs.X * lhs, rhs.Y * lhs, rhs.W * lhs, rhs.H * lhs); return rhs; &#125;&#125;public class TreeObject&#123; /// &lt;summary&gt; /// 信息 /// &lt;/summary&gt; public TreeRect TreeRect; /// &lt;summary&gt; /// 属于哪个节点 /// &lt;/summary&gt; public MapQuadTree Node ; public int Id;&#125;public class MapQuadTree&#123; public MapQuadTree Root &#123; get; &#125; //根节点 public int MaxCount &#123; get; private set; &#125; = 5; public int MaxDeep &#123; get; private set; &#125; = 4; public int TreeDeep &#123; get; &#125; public List&lt;MapQuadTree&gt; Childs &#123; get; private set; &#125; public MapQuadTree Parent &#123; get; &#125; /// &lt;summary&gt; /// &lt;/summary&gt; public readonly List&lt;TreeObject&gt; TreePointObjs = new List&lt;TreeObject&gt;(); // public readonly List&lt;TreeObject&gt; BoundTreeObjs = new List&lt;TreeObject&gt;(); public TreeRect Rect &#123; get; &#125; public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0; public bool IsEmptyLeafNode =&gt; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode ; public MapQuadTree(TreeRect rect) &#123; Rect = rect; TreeDeep = 0; Root = this; &#125; private MapQuadTree(TreeRect rect, int treeDeep, MapQuadTree parent) : this(rect) &#123; TreeDeep = treeDeep + 1; this.Parent = parent; Root = parent.Root; &#125; public void Insert(TreeObject treeObj) &#123; if (!IsInTreeRect(treeObj)) &#123; return; &#125; treeObj.Node = this; if (Childs == null) &#123; TreePointObjs.Add(treeObj); if (TreePointObjs.Count &gt; MaxCount) &#123; SliceTree(); &#125; &#125; else &#123; for (int i = 0; i &lt; Childs.Count; i++) &#123; Childs[i].Insert(treeObj); &#125; &#125; &#125; private void SliceTree() &#123; if (TreeDeep &gt;= MaxDeep) &#123; return; &#125; // 四分 可根据情况 调整 // lb, lt, rt, rb 目前与unity recttranform 的 4个 corner 保持一致的分布顺序 Childs = new List&lt;MapQuadTree&gt; &#123; new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadTree(new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadTree(new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this) &#125;; for (int i = 0; i &lt; TreePointObjs.Count; i++) &#123; for (int j = 0; j &lt; Childs.Count; j++) &#123; Childs[j].Insert(TreePointObjs[i]); &#125; &#125; TreePointObjs.Clear(); &#125; public bool Intersect(TreeRect other) &#123; return Rect.Intersect(other); &#125; private bool IsInTreeRect(TreeObject treeObj) &#123; return Rect.IsCenterIn(treeObj.TreeRect); &#125; public void ClearEmptyNode() &#123; List&lt;MapQuadTree&gt; emptyLeafNodes = new List&lt;MapQuadTree&gt;(); ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;); while (emptyLeafNodes.Count &gt; 0) &#123; for (int i = 0; i &lt; emptyLeafNodes.Count; i++) &#123; emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]); &#125; emptyLeafNodes.Clear(); ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;); &#125; &#125; private void ForEachEmptyLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction) &#123; if (node.IsEmptyLeafNode) &#123; treeAction?.Invoke(node); return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachEmptyLeafNode(node.Childs[i],treeAction); &#125; &#125; &#125; private void ForEachLeafNode(MapQuadTree node, Action&lt;MapQuadTree&gt; treeAction) &#123; if (node.IsLeafNode) &#123; treeAction?.Invoke(node); return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachLeafNode(node.Childs[i],treeAction); &#125; &#125; &#125; private void RemoveChildNode(MapQuadTree node) &#123; if (Childs!=null) &#123; Childs.Remove(node); &#125; &#125; public void ForEach(Action&lt;MapQuadTree&gt; each) &#123; ForEach(Root, each); &#125; public void ForEachInRect(TreeRect rect, Action&lt;MapQuadTree&gt; treeAction) &#123; ForEachAreaTree(Root, rect, treeAction); &#125; private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;MapQuadTree&gt; treeAction) &#123; if (!node.Rect.Intersect(rect)) &#123; return; &#125; if (node.IsLeafNode) &#123; treeAction?.Invoke(node); return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachAreaTree(node.Childs[i], rect, treeAction); &#125; &#125; &#125; public void ForEachInRect(TreeRect rect, Action&lt;TreeObject&gt; treeAction) &#123; ForEachAreaTree(Root, rect, treeAction); &#125; private void ForEachAreaTree(MapQuadTree node, TreeRect rect, Action&lt;TreeObject&gt; treeAction) &#123; if (!node.Rect.Intersect(rect)) &#123; return; &#125; if (node.IsLeafNode) &#123; foreach (var treeObject in node.TreePointObjs) &#123; treeAction?.Invoke(treeObject); &#125; return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachAreaTree(node.Childs[i], rect, treeAction); &#125; &#125; &#125; private void ForEach(MapQuadTree node, Action&lt;MapQuadTree&gt; each) &#123; if (node == null) &#123; return; &#125; ForEachNodeValues(node, each); if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachNodeValues(node.Childs[i], each); ForEach(node.Childs[i], each); &#125; &#125; &#125; private void ForEachNodeValues(MapQuadTree node, Action&lt;MapQuadTree&gt; each) &#123; each?.Invoke(node); &#125; public override string ToString() &#123; return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;; &#125;&#125; 只要点和边框必须在区域内就可以插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293using System;using System.Collections.Generic;public class BoundTreeObject&#123; public TreeRect TreeRect; public MapQuadBoundTree Node; public int Id;&#125;public class MapQuadBoundTree&#123; public MapQuadBoundTree Root &#123; get; &#125; //根节点 public int MaxCount &#123; get; private set; &#125; = 5; public int MaxDeep &#123; get; private set; &#125; = 5; public int TreeDeep &#123; get; &#125; public List&lt;MapQuadBoundTree&gt; Childs &#123; get; private set; &#125; public MapQuadBoundTree Parent &#123; get; &#125; private TreeRect[] _treeChildRects = new TreeRect[4]; public readonly List&lt;BoundTreeObject&gt; TreePointObjs = new List&lt;BoundTreeObject&gt;(); public readonly List&lt;BoundTreeObject&gt; BoundTreeObjs = new List&lt;BoundTreeObject&gt;(); public TreeRect Rect &#123; get; &#125; public bool IsLeafNode =&gt; Childs == null || Childs.Count == 0; public bool IsEmptyLeafNode =&gt; BoundTreeObjs.Count == 0 &amp;&amp; TreePointObjs.Count == 0 &amp;&amp; IsLeafNode; public MapQuadBoundTree(TreeRect rect) &#123; Rect = rect; TreeDeep = 0; Root = this; _treeChildRects[0] = new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH); _treeChildRects[1] = new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH); _treeChildRects[2] = new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH); _treeChildRects[3] = new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH); &#125; private MapQuadBoundTree(TreeRect rect, int treeDeep, MapQuadBoundTree parent) : this(rect) &#123; TreeDeep = treeDeep + 1; this.Parent = parent; Root = parent.Root; &#125; public void Insert(BoundTreeObject treeObj) &#123; if (!IsInTreeRect(treeObj)) &#123; return; &#125; treeObj.Node = this; if (IsAllInsert(treeObj)) &#123; BoundTreeObjs.Add(treeObj); return; &#125; if (Childs == null) &#123; TreePointObjs.Add(treeObj); if (TreePointObjs.Count &gt; MaxCount) &#123; SliceTree(); &#125; &#125; else &#123; for (int i = 0; i &lt; Childs.Count; i++) &#123; Childs[i].Insert(treeObj); &#125; &#125; &#125; private bool IsAllInsert(BoundTreeObject treeObj) &#123; int count = 0; for (int i = 0; i &lt; _treeChildRects.Length; i++) &#123; if (_treeChildRects[i].Intersect(treeObj.TreeRect)) &#123; if (count &gt; 0) &#123; return true; &#125; count++; &#125; &#125; return false; &#125; private void SliceTree() &#123; if (TreeDeep &gt;= MaxDeep) &#123; return; &#125; // lb, lt, rt, rb 目前与unity recttranform 的 4个 corner 保持一致的分布顺序 Childs = new List&lt;MapQuadBoundTree&gt; &#123; new MapQuadBoundTree( new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadBoundTree( new TreeRect(Rect.X - Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadBoundTree( new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y + Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this), new MapQuadBoundTree( new TreeRect(Rect.X + Rect.HalfW * 0.5f, Rect.Y - Rect.HalfH * 0.5f, Rect.HalfW, Rect.HalfH), TreeDeep, this) &#125;; for (int i = 0; i &lt; TreePointObjs.Count; i++) &#123; for (int j = 0; j &lt; Childs.Count; j++) &#123; Childs[j].Insert(TreePointObjs[i]); &#125; &#125; TreePointObjs.Clear(); &#125; public bool Intersect(TreeRect other) &#123; return Rect.Intersect(other); &#125; private bool IsInTreeRect(BoundTreeObject treeObj) &#123; return Rect.IsCenterIn(treeObj.TreeRect); &#125; public void ClearEmptyNode() &#123; // TODO 清除空节点 只需从叶节点删除 List&lt;MapQuadBoundTree&gt; emptyLeafNodes = new List&lt;MapQuadBoundTree&gt;(); ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;); while (emptyLeafNodes.Count &gt; 0) &#123; for (int i = 0; i &lt; emptyLeafNodes.Count; i++) &#123; emptyLeafNodes[i].Parent.RemoveChildNode(emptyLeafNodes[i]); &#125; emptyLeafNodes.Clear(); ForEachEmptyLeafNode(Root, (t) =&gt; &#123; emptyLeafNodes.Add(t); &#125;); &#125; &#125; private void ForEachEmptyLeafNode(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; treeAction) &#123; if (node.IsEmptyLeafNode) &#123; treeAction?.Invoke(node); return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachEmptyLeafNode(node.Childs[i], treeAction); &#125; &#125; &#125; private void RemoveChildNode(MapQuadBoundTree node) &#123; if (Childs != null) &#123; Childs.Remove(node); &#125; &#125; public void ForEach(Action&lt;MapQuadBoundTree&gt; each) &#123; ForEach(Root, each); &#125; public void ForEachInRect(TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction) &#123; ForEachAreaTree(Root, rect, treeAction); &#125; private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;MapQuadBoundTree&gt; treeAction) &#123; if (!node.Rect.Intersect(rect)) &#123; return; &#125; if (node.IsLeafNode) &#123; treeAction?.Invoke(node); return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachAreaTree(node.Childs[i], rect, treeAction); &#125; &#125; &#125; public void ForEachInRect(TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction) &#123; ForEachAreaTree(Root, rect, treeAction); &#125; private void ForEachAreaTree(MapQuadBoundTree node, TreeRect rect, Action&lt;BoundTreeObject&gt; treeAction) &#123; if (!node.Rect.Intersect(rect)) &#123; return; &#125; foreach (var boundTreeObj in node.BoundTreeObjs) &#123; if (boundTreeObj.TreeRect.Intersect(rect)) &#123; treeAction?.Invoke(boundTreeObj); &#125; &#125; if (node.IsLeafNode) &#123; foreach (var boundTreeObj in node.TreePointObjs) &#123; if (boundTreeObj.TreeRect.Intersect(rect)) &#123; treeAction?.Invoke(boundTreeObj); &#125; &#125; return; &#125; if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachAreaTree(node.Childs[i], rect, treeAction); &#125; &#125; &#125; private void ForEach(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each) &#123; if (node == null) &#123; return; &#125; ForEachNodeValues(node, each); if (node.Childs != null) &#123; for (int i = 0; i &lt; node.Childs.Count; i++) &#123; ForEachNodeValues(node.Childs[i], each); ForEach(node.Childs[i], each); &#125; &#125; &#125; private void ForEachNodeValues(MapQuadBoundTree node, Action&lt;MapQuadBoundTree&gt; each) &#123; each?.Invoke(node); &#125; public override string ToString() &#123; return $&quot;Deep :&#123;TreeDeep&#125; : &#123;Rect.ToString()&#125; ,+ &#123;TreePointObjs.Count&#125; &quot;; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://leolichenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://leolichenxi.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"GoogleProtobuffer","slug":"Tools/GoogleProtobuffer","date":"2021-06-14T04:00:00.000Z","updated":"2021-06-16T08:51:50.686Z","comments":true,"path":"2021/06/14/Tools/GoogleProtobuffer/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/Tools/GoogleProtobuffer/","excerpt":"","text":"Protocolbuffers 官方git地址 官方文档地址 官方Release 知乎介绍 Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 常见的数据格式：XML,Json,Protobuf,FlatBuffers 等其它。 数据储存 数据交换格式 使用流程： 1.编写Scheme;2.使用Protoc 生成代码； 下载Release Protoc代码生成工具 Release中下载Window 或 Mac Os 设置环境变量在下载程序后，需要将下载 zip 文件中的 bin 目录设置到环境变量中。 然后运行 protoc –version 来确定你的编译运行版本已经被正确配置。 使用官方文档地址 生成代码命令 eg: protoc – csharp_out=SciptOutFolder/ ProtoFolder/filename.proto Protocol Buffer 编码原理采用Varint编码规则 Varint编码variant是可变长的编码方式,Varint是一种使用一个或多个字节序列化整数的方法，会把整数编码变为长字节，对于32位整型进过Variant编码后需要1-5个字节,小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用1~10个字节。在实际场景中小数字的使用率远远大于大数字，因此Varint编码对于大部分的场景都可以起到很好的压缩效果。 编码原理除了最后一个字节外,Varint编码中的每个字节都设置了最高有效位（most significant bit - msb）–msb为1则表明后面的字节还是属于当前数据的,如果是0那么这是当前数据的最后一个字节数据。每个字节的第7位用于以7位为一组存储数字的二进制补码表示，最低有效组在前，或者叫最低有效字节在前。这表明varint编码后数据的字节是按照小端序排列的。 关于字节排列的方式引用一下维基百科上的词条 字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。 通俗一点说就是：大端序是按照数字的书写顺序排列的，而小端序是颠倒书写顺序进行排列的。 variant编码对负数编码效率低","categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"}],"tags":[{"name":"GoogleProtobuffer","slug":"GoogleProtobuffer","permalink":"https://leolichenxi.github.io/tags/GoogleProtobuffer/"}]},{"title":"ECS架构","slug":"U3D/ECS/ECS架构","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:07:33.626Z","comments":true,"path":"2021/06/14/U3D/ECS/ECS架构/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/ECS/ECS%E6%9E%B6%E6%9E%84/","excerpt":"","text":"ECS ,即 Entity-Component-System 的缩写，其模式遵循组合优于继承原则，游戏内的每一个单位都是一个实体，每个实体又又一个或多个组件构成，每个组件仅仅包含代表其特性的数据(即在组件中没有任何方法),系统便是来处理拥有一个或多个相同组件的实体集合的工具，其只拥有行为，在这个例子中，处理移动的系统仅仅关心拥有移动能力的实体，它会遍历所有拥有相关组件的实体，并根据相关的数据，更新实体。 这里核心思路区别于Unity ECS，提供一个设计思路。Unity 后面单独研究下 ECS 获取组件较为麻烦。","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"开发流程-客户端-策划配置数据","slug":"开发流程管理/策划配置表管理","date":"2021-06-14T04:00:00.000Z","updated":"2021-08-11T09:36:14.098Z","comments":true,"path":"2021/06/14/开发流程管理/策划配置表管理/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AD%96%E5%88%92%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"客户端配置数据管理 开发或上线后不可避免的出现配置逻辑错误问题，系统功能通常会给策划留有很大的配置空间用于铺量和修改，但不可避免的会有错误，这里记录下配置表检查的原则 必须检查的情况 id 与其它表格关联 配置资源路径，必须判断资源是否存在 配置要求一定得格式，比如约定的分隔符 1;2 分割数组，可能会配置成1,2 有 type:id type 不同id 指向不用配置表，必须检查。 未完待续…..","categories":[{"name":"开发流程","slug":"开发流程","permalink":"https://leolichenxi.github.io/categories/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"}],"tags":[{"name":"开发流程","slug":"开发流程","permalink":"https://leolichenxi.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"}]},{"title":"1.从Unlit-Color开始入手","slug":"Shader/1笔记_builtin_shaders_Unlit-Color","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:10:49.482Z","comments":true,"path":"2021/06/14/Shader/1笔记_builtin_shaders_Unlit-Color/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/Shader/1%E7%AC%94%E8%AE%B0_builtin_shaders_Unlit-Color/","excerpt":"","text":"Shader 源码-Unlit-Color需要有一定的shader基础，深刻理解unity 内置shader的实现原里。 先贴代码，逐步分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)// Unlit shader. Simplest possible colored shader.// - no lighting// - no lightmap support// - no textureShader &quot;Unlit/Color&quot;&#123; Properties &#123; _Color (&quot;Main Color&quot;, Color) = (1, 1, 1, 1) &#125; SubShader &#123; Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125; LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma target 2.0 #pragma multi_compile_fog #include &quot;UnityCG.cginc&quot; struct appdata_t &#123; float4 vertex: POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID &#125;; struct v2f &#123; float4 vertex: SV_POSITION; UNITY_FOG_COORDS(0) UNITY_VERTEX_OUTPUT_STEREO &#125;; fixed4 _Color; v2f vert(appdata_t v) &#123; v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); o.vertex = UnityObjectToClipPos(v.vertex); UNITY_TRANSFER_FOG(o, o.vertex); return o; &#125; fixed4 frag(v2f i): SV_Target &#123; fixed4 col = _Color; UNITY_APPLY_FOG(i.fogCoord, col); UNITY_OPAQUE_ALPHA(col.a); return col; &#125; ENDCG &#125; &#125;&#125; #pragma multi_compile_fog实现很简单，重点点记录 #pragma multi_compile_fog UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_FOG_COORDS(0) UNITY_VERTEX_OUTPUT_STEREO UNITY_SETUP_INSTANCE_ID(v) UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o) UNITY_TRANSFER_FOG(o, o.vertex) UNITY_APPLY_FOG(i.fogCoord, col) UNITY_OPAQUE_ALPHA(col.a) 这些在一个基础的顶点片元着色器的基本原里。 基础概念宏定义12345678910#define 标识 //定义标识，如果 （标识） 已经被标识过会报错。#undef 标识 //取消标识的定义#ifdef 标识 //判断某个宏是否被定义，若已定义，执行随后的语句#ifndef 标示 // 判断&quot;标示&quot;是否定义，如果被定义则返回false，如果没有被定义则返回true#if //编译预处理中的条件命令，相当于C语法中的if语句#elif // 若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if#else //与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else#endif //#if, #ifdef, #ifndef这些条件命令的结束标志. defined(宏) 与#if, #elif配合使用，判断某个宏是否被定义 #include “UnityCG.cginc”这里需要注意下,include并不是像c++ 这样在调用shader时将文件include进去，而是在编译shader时决定生成的代码。可以测试在去掉#pragma multi_compile_fog前后点击shader面板 Compile and show code 查看编译后的代码。 追到UnityCG.cginc文件中查看UNITY_FOG_COORDS宏 1234567891011121314151617181920212223#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2) #define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1) #if (SHADER_TARGET &lt; 30) || defined(SHADER_API_MOBILE) // mobile or SM2.0: calculate fog factor per-vertex #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.tSpace1.y = tangentSign; o.tSpace2.y = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.worldPos.w = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.eyeVec.w = unityFogFactor #else // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel #define UNITY_TRANSFER_FOG(o,outpos) o.fogCoord.x = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) o.tSpace2.y = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) o.worldPos.w = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) o.eyeVec.w = (outpos).z #endif#else #define UNITY_FOG_COORDS(idx) #define UNITY_TRANSFER_FOG(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos)#endif 当开启Fog时 1#define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1) UNITY_FOG_COORDS_PACKED 1#define UNITY_FOG_COORDS_PACKED(idx, vectype) vectype fogCoord : TEXCOORD##idx; 可知实际 UNITY_FOG_COORDS(0) 如果Fog开启,相当一在片元数据中定义了 1float1 fogCoord : TEXCOORD0 UNITY_TRANSFER_FOG 12345678910111213141516171819202122232425 #if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2) #define UNITY_FOG_COORDS(idx) UNITY_FOG_COORDS_PACKED(idx, float1) #if (SHADER_TARGET &lt; 30) || defined(SHADER_API_MOBILE) // mobile or SM2.0: calculate fog factor per-vertex #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.tSpace1.y = tangentSign; o.tSpace2.y = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.worldPos.w = unityFogFactor #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.eyeVec.w = unityFogFactor #else // SM3.0 and PC/console: calculate fog distance per-vertex, and fog factor per-pixel #define UNITY_TRANSFER_FOG(o,outpos) o.fogCoord.x = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) o.tSpace2.y = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) o.worldPos.w = (outpos).z #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos) o.eyeVec.w = (outpos).z #endif#else #define UNITY_FOG_COORDS(idx) #define UNITY_TRANSFER_FOG(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,outpos) #define UNITY_TRANSFER_FOG_COMBINED_WITH_EYE_VEC(o,outpos)#endif 因为 #pragma target 2.0 时 SHADER_TARGET &lt;30 所以 12345678910111213141516171819#if defined(FOG_LINEAR) // factor = (end-z)/(end-start) = z * (-1/(end-start)) + (end/(end-start)) #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = (coord) * unity_FogParams.z + unity_FogParams.w#elif defined(FOG_EXP) // factor = exp(-density*z) #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.y * (coord); unityFogFactor = exp2(-unityFogFactor)#elif defined(FOG_EXP2) // factor = exp(-(density*z)^2) #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = unity_FogParams.x * (coord); unityFogFactor = exp2(-unityFogFactor*unityFogFactor)#else #define UNITY_CALC_FOG_FACTOR_RAW(coord) float unityFogFactor = 0.0#endif#define UNITY_CALC_FOG_FACTOR(coord) UNITY_CALC_FOG_FACTOR_RAW(UNITY_Z_0_FAR_FROM_CLIPSPACE(coord)) #define UNITY_TRANSFER_FOG(o,outpos) UNITY_CALC_FOG_FACTOR((outpos).z); o.fogCoord.x = unityFogFactor 可以追溯宏定义的运算 得到 fogCoord值,并在 UNITY_APPLY_FOG(i.fogCoord, col);得到新得col值。 备注INSTANCE 和FOG 会在后面补充，这里只记录shader分析的一个过程。","categories":[{"name":"ShaderLab","slug":"ShaderLab","permalink":"https://leolichenxi.github.io/categories/ShaderLab/"}],"tags":[{"name":"builtin_shaders","slug":"builtin-shaders","permalink":"https://leolichenxi.github.io/tags/builtin-shaders/"}]},{"title":"AndroidAppBundle","slug":"U3D/aab打包","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:07:21.602Z","comments":true,"path":"2021/06/14/U3D/aab打包/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/aab%E6%89%93%E5%8C%85/","excerpt":"","text":"官方文档 AndroidAppBundle googlePlay上一种新的上传格式，以前是传apk,现在可以传Bundle。google play通过dynamic Delevery从Bundle中现在特定的配置给用户。 Play Asset DeliveryPlay Asset Delivery (PAD) 将 app bundle 的优势带到游戏中。它允许超过 150 MB 的游戏替换旧版扩展文件 (OBB)，方法是将包含游戏所需的所有资源的单个工件发布到 Play。PAD 提供了灵活的分发模式、自动更新、压缩和增量修补功能，并且可免费使用。使用 PAD，所有资源包均在 Google Play 上托管和提供，因此您无需使用内容分发网络 (CDN) 向玩家提供游戏资源。 Play Asset Delivery 使用资源包，资源包由资源（如纹理、着色器和声音）组成，但不包含可执行代码。通过 Dynamic Delivery，您可以按照以下三种分发模式自定义如何以及何时将各个资源包下载到设备上：安装时分发、快速跟进式分发和按需分发。 install-time资源包在用户安装应用时分发。这些资源包以拆分 APK（APK 集的一部分）的形式提供。它们也称为“预先”资源包；您可以在应用启动时立即使用这些资源包。这些资源包会增加 Google Play 商店上列出的应用大小。用户无法修改或删除这些资源包。 fast-follow资源包会在用户安装应用后立即自动下载；用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。这些资源包会增加 Google Play 商店上列出的应用大小。 on-demand资源包会在应用运行时下载。 Google Play 商店会以归档文件（而非拆分 APK）的形式提供配置为 fast-follow 和 on-demand 的资源包。这些资源包随后会在应用的内部存储空间中展开。您可以使用 Play Core API 查询以这种方式提供的资源包的位置。应用无法假设这些文件的存在或其位置，因为它们可能会被用户删除，或由 Play Core SDK 在游戏会话之间移动。尽管这些文件可由应用写入，您也应将其视为只读文件，因为资源包补丁程序依赖于这些文件的完整性。 每个 fast-follow 和 on-demand Asset Pack 的下载大小上限为 512 MB。所有 install-time Asset Pack 的总下载大小上限为 1 GB。一个 Android App Bundle 中的所有 Asset Pack 的总下载大小上限为 2 GB。一个 Android App Bundle 中最多可以使用 50 个资源包。 也就是从install-time 我们可以放比较多的重要资源 fast-follow 和 on-demand 放二级资源 我们项目目前有将近4G 的资源 最新的assetbundle（3.75G） 从PAD中可以处理将近2G的资源，仍需有将近2G的资源从cdn下载。 PAD需要处理的工作 打包时记录所有的AssetPack信息, 测试分支已经写好。（每个pack的文件和大小信息等。）加入自动打包也已改好。 根据记录的pack信息 在应用启动时对PAD做资源完整检查; 每个分包的PlayAssetPack的处理（分包里的assetbundle 或其它资源，需要先加载此AssetPack 再从assetPack里加载assetbundle）这里包含任何分发模式的资源。 加载AssetBundle的逻辑修改这里主要是是 以及AssetPack在内存中的依赖维护。 123456789//异步加载PlayAssetPackRequest playAssetPackRequest = PlayAssetDelivery.RetrieveAssetPackAsync(packName); //异步加载AssetBundleCreateRequest request = playAssetPackRequest.LoadAssetBundleAsync(abPath)//目前的加assetbundle AssetBundleCreateRequest request = AssetBundle.LoadFromFileAsync(AssetBundleFullPath); 在 Play 上测试 app bundlehttps://developer.android.com/guide/app-bundle/test 本地测试流程官方测试参考文档 下载BundleTool 将aab装成课本第测试的apks 此步骤以自动加入到打包流程。 123bundletool build-apks --local-testing --bundle my_app.aab --output my_app.apks 安装到测试机(模拟器需要abd 先链接模拟器，比如夜神模拟器：adb connect 127.0.0.1:62001) 1bundletool install-apks --apks my_app.apks","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"AAB","slug":"AAB","permalink":"https://leolichenxi.github.io/tags/AAB/"}]},{"title":"优化记录 - 1","slug":"U3D/优化","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:07:24.638Z","comments":true,"path":"2021/06/14/U3D/优化/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/%E4%BC%98%E5%8C%96/","excerpt":"","text":"优化的最终是希望代码占用内存小的同时执行效率高。 unity 分为CPU 和 GPU 优化 CPUGPU","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"优化","slug":"优化","permalink":"https://leolichenxi.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"Audio","slug":"U3D/资源管理/audio优化","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:07:47.100Z","comments":true,"path":"2021/06/14/U3D/资源管理/audio优化/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/audio%E4%BC%98%E5%8C%96/","excerpt":"","text":"导入前的声音格式选择 短声音：.aifff和.wav 长声音：.mp3和.ogg 导入后的声音格式选择 Force ToMono：如果启用，该音频将向下混合到单声道 Load In Backgroud: 加载将在一个单独的线程上延迟的时间发生，而不会阻塞主线程 Ambisonic: 如果音频文件包含有双声编码的音频，那么启用这个选项 LoadType: ①Decompress On Load:处理较小的声音（load就解压） ②Compressed In Memory：较大的声音（保持解压的状态） ③Streaming：使用最少的内存来缓冲压缩数据（很长的音乐） Compression Format： ①PCM 非常短的音效是最好的，质量高，文件大 ②ADPCM大量噪音的声音，需要大量播放，比如脚步声，武器 ③Vorbis/MP3 质量低，中等长度背景音乐 ④HEVAG 类似于adpcm Preload Audio Data 预加载 方案：大点的音频: Streaming,不预加载，Vorbis 小点的音频DecompressOnLoad 不预加载 ，Vorbis 会优化比较适中的cpu和内存，具体还要根据项目实际确定 Unity性能优化-音频设置没想到Unity的音频会成为内存杀手，在实际的商业项目中，音频的优化必不可少。 Unity支持许多不同的音频格式，但最终它将它们全部转换为首选格式。音频压缩格式有PCM、ADPCM、Vorbis，不是所有平台都支持这些所有的压缩格式，有些平台，例如WebGL只支持AAC格式。 所有音频导入时，默认两项设置，LoadType是”Decompress On Load”，压缩格式是“Vorbis”，例如下图原始文件大小计算为35.9 MB，导入的大小计算为10.7 MB。这意味着这个音频剪辑将使您的游戏（存档）大小增加10兆字节，但播放它需要近36兆字节的RAM。 These are default import settings. Load Type的各个选项 Compressed In Memory – 音频剪辑将存储在RAM中，播放时将解压缩，播放时不需要额外的存储。Streaming –音频永久存在设备上(硬盘或闪存上) ，播放流媒体方式. 不需要RAM进行存储或播放。Decompress On Load – 未压缩的音频将存储在RAM中。这个选项需要的内存最多，但是播放它不会像其他选项那样需要太多的CPU电源。 怎么选？长音频播放消耗大量内存，如果播放时不想在内存中进行解压，有两个选择： （1）Load Type选“Streaming”， Compression Format 选”Vorbis&quot;，使用最少的内存，但需要更多的CPU电量和硬盘I/O操作； （2）Load Type选“Compressed In Memory”， Compression Format 选”Vorbis&quot;，磁盘I/O操作被替换成内存的消耗，请注意，要调整“Quaility”滑块以减小压缩剪辑的大小，以交换音质，一般推荐70%左右。 一般是看到底音乐占据多少内存以及你的目标机型是什么样子的，如果音乐占据的内存本身比较高，你的目标机型的内存又比较小，那么就选择第二种，这种方案会卡一点，否则选择第一种就更好 声音特效 （1）对于经常播放的和短的音频剪辑，使用“Decompress On Load”和“PCM或ADPCM”压缩格式。当选择PCM时，不需要解压缩，如果音频剪辑很短，它将很快加载。你也可以使用ADPCM。它需要解压，但解压比Vorbis快得多。 （2）对于经常播放，中等大小的音频剪辑使用”Compressed In Memory“和”ADPCM“压缩格式，比原始PCM小3.5倍，解压算法的CPU消耗量不会像vorbis消耗那么多CPU。 （3）对于很少播放并且长度比较短的声音剪辑，使用”Compressed In Memory”, ADPCM 这种压缩格式,原因同（2）。 （4）对于很少播放中等大小的音频，使用”Compressed In Memory“ 和Vorbis压缩格式。这个音频可能太长，无法使用adpcm存储，播放太少，因此解压缩所需的额外CPU电量不会太多。","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://leolichenxi.github.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"Lua 内存 和 GC","slug":"Lua/lua内存","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-06T10:32:43.864Z","comments":true,"path":"2021/06/14/Lua/lua内存/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/Lua/lua%E5%86%85%E5%AD%98/","excerpt":"","text":"1 byte (B 字节) = 8 bits (b 比特位，0或1)1 KB = 1024 (2^10) byte1MB = 1024 KB1GB = 1024 MB1TB = 1024 GB## 基础数据类型 number 实数，可以是整数，浮点数 string 字符串，一旦赋值不能被修改，可以通过方法string.gsub()来修改 nil 全局变量没被赋值默认为nil，删除变量酒赋值为nil boolean false 和 nil为假，其它都为真 function函数 table 数组，容器 userdata (类，其它语言转换过来就变成userdata类) thread 线程 Lua GC 在Lua5.1后，lua采用分布回收以及三色增量标记清除算法，基本原里： 每个新创建的对象设置为白色 遍历root节点中引用的对象，从白色置为灰色，并且放入到灰色节点链表中 从灰色链表中取未扫描到的对象，将其置为黑色，遍历这个对象关联的其他所有对象：如果为白色，则标记为灰色并加入到灰色链表中 遍历所有对象，如果是白色，执行灰色，否则塞入到对象链表中，等待下一轮GC","categories":[{"name":"lua","slug":"lua","permalink":"https://leolichenxi.github.io/categories/lua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://leolichenxi.github.io/tags/lua/"}]},{"title":"ADB调试","slug":"U3D/ADB调试","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:10:56.849Z","comments":true,"path":"2021/06/14/U3D/ADB调试/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/ADB%E8%B0%83%E8%AF%95/","excerpt":"","text":"adb 链接设备adb connect 127.0.0.1:62001 查看设备链接adb devices 查看内存adb shell top | grep app_nameadb shell top | grep com.bilibili.hcshjxaz 链接Unityadb forward tcp:34999 localabstract:包名","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://leolichenxi.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"AssetBundle优化","slug":"U3D/资源管理/Assetbundle优化","date":"2021-06-14T04:00:00.000Z","updated":"2022-02-21T11:08:03.545Z","comments":true,"path":"2021/06/14/U3D/资源管理/Assetbundle优化/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/Assetbundle%E4%BC%98%E5%8C%96/","excerpt":"","text":"1.一.BuildAssetBundleOption.DisableWriteTypeTree 关闭","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://leolichenxi.github.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"cmd-常用命令","slug":"Shell/cmd","date":"2021-06-14T04:00:00.000Z","updated":"2023-01-05T07:32:16.529Z","comments":true,"path":"2021/06/14/Shell/cmd/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/Shell/cmd/","excerpt":"","text":"ipconfig /flushdnsipconfigpingcd","categories":[{"name":"shell","slug":"shell","permalink":"https://leolichenxi.github.io/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://leolichenxi.github.io/tags/shell/"}]},{"title":"Imposters方案探索","slug":"U3D/Impostors","date":"2021-06-14T04:00:00.000Z","updated":"2023-06-13T02:52:24.209Z","comments":true,"path":"2021/06/14/U3D/Impostors/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/U3D/Impostors/","excerpt":"","text":"Unity下两个Imposters(替代体)方案的插件介绍——Amplify Imposters与Runtime ImpostersAmplify Imposters下载地址：https://assetstore.unity.com/packages/tools/utilities/amplify-impostors-119877Runtime Imposters下载地址：https://assetstore.unity.com/packages/tools/utilities/impostors-runtime-optimization-188562算法地址：True Imposters: https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-21-true-impostorsOctahedral Impostors: https://shaderbits.com/blog/octahedral-impostors/","categories":[{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"}],"tags":[{"name":"优化","slug":"优化","permalink":"https://leolichenxi.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"代码篇","slug":"代码篇/位运算","date":"2021-06-14T04:00:00.000Z","updated":"2023-06-13T02:28:46.038Z","comments":true,"path":"2021/06/14/代码篇/位运算/","link":"","permalink":"https://leolichenxi.github.io/2021/06/14/%E4%BB%A3%E7%A0%81%E7%AF%87/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"位运算 程序中的所有数在计算机内都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。 见的运算符有与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;是带符号右移 &gt;&gt;&gt;无符号右移动) 位运算 与(&amp;) 二进制对应位两两进行逻辑AND运算（只有对应的值都是1时结果才为1，否则为0），即0&amp;0=0，0&amp;1=0，1&amp;1=1 位运算|（或） 对二进制对应位两两进行逻辑或运算（其中一个为1则为1） 即 0|0 =0， 0|1=1，1|1 =1 位运算 ^(异或) 二进制对应位两两进行逻辑异或的运算（当对应位的值不同时位0） 0^0=0， 0^1=1,1^1=0 按位取反 ~ 二进制的0变成1，1变成0 移位运算符左移运算 &lt;&lt;： 左移后右边位补0右移运算 &gt;&gt;: 右移后左边位补0","categories":[{"name":"基础","slug":"基础","permalink":"https://leolichenxi.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://leolichenxi.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Hexo Pure主题设置记录","slug":"Hexo/Hexo-Pure-设置","date":"2021-06-11T05:43:00.000Z","updated":"2023-01-05T07:29:39.582Z","comments":true,"path":"2021/06/11/Hexo/Hexo-Pure-设置/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/Hexo/Hexo-Pure-%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"Pure 设置记录hexo-theme-pure git文档地址：文档地址 背景动态设置背景动画 基于canvas，在\\themes\\pure\\layout\\layout.ejs的body中面添加 123&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; gitcommet 设置12345678910111213comment: type: gitment # 启用哪种评论系统 # disqus: # enter disqus shortname here # youyan: # uid: 2kLH6P3hQG2bNQQ9a9mwRFmd-gzGzoHsz # enter youyan uid # livere: # uid: # enter youyan uid gitment: githubID: githubname repo: githubname.github.io ClientID: id ClientSecret: secrectid lazy: false 访问数设置footer.ejs脚本 12345678910&lt;footer class=&quot;footer&quot; itemscope itemtype=&quot;http://schema.org/WPFooter&quot;&gt; &lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;% if(theme.site.copyright) &#123; %&gt; &amp;copy; &lt;%= date(new Date(), &#x27;YYYY&#x27;) %&gt; &lt;%= config.author || config.title %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span &gt;本站总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/footer&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://leolichenxi.github.io/categories/Hexo/"}],"tags":[{"name":"pure","slug":"pure","permalink":"https://leolichenxi.github.io/tags/pure/"}]},{"title":"1.UE4-安装-Rider for Unreal Engine","slug":"UE4/1.UE4-安装-Rider for Unreal Engine","date":"2021-06-11T05:43:00.000Z","updated":"2021-06-11T15:35:21.353Z","comments":true,"path":"2021/06/11/UE4/1.UE4-安装-Rider for Unreal Engine/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/UE4/1.UE4-%E5%AE%89%E8%A3%85-Rider%20for%20Unreal%20Engine/","excerpt":"","text":"安装UE4教程比较多，自行搜索 个人安装的： UE4版本 4.24.3 IDE Rider for Unreal Engine 安装后找到此插件 安装 Rider for Unreal Engine； 安装后修改配置 修改Rider缓存目录：Rider for Unreal Engine 2021.1.1\\bin 文件夹下idea.properties文件 修改ue4缓存目录 用记事本打开它，然后搜索InstalledDerivedDataBackendGraph并找到%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache把它改为%GAMEDIR%DerivedDataCache","categories":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/categories/UE4/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/tags/UE4/"}]},{"title":"Hexo使用记录","slug":"Hexo/Hexo使用","date":"2021-06-11T05:43:00.000Z","updated":"2023-03-16T02:01:03.970Z","comments":true,"path":"2021/06/11/Hexo/Hexo使用/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/Hexo/Hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo 安装记录[地址文档] (https://hexo.io/zh-cn) hexo g -生成 hexo s -开启服务器 hexo d -生成上传 markdown 图片测试问题 在写.md文档时，采用在source 目录下新建个images文件夹。引用图片直接 (/images/图片名)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://leolichenxi.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://leolichenxi.github.io/tags/hexo/"}]},{"title":"UE4-踩坑记录","slug":"UE4/0.UE4-踩坑记录","date":"2021-06-11T05:43:00.000Z","updated":"2021-06-11T07:45:33.527Z","comments":true,"path":"2021/06/11/UE4/0.UE4-踩坑记录/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/UE4/0.UE4-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"","categories":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/categories/UE4/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/tags/UE4/"}]},{"title":"3.UE4-FString","slug":"UE4/3.UE4-FString","date":"2021-06-11T05:43:00.000Z","updated":"2021-06-11T07:47:10.191Z","comments":true,"path":"2021/06/11/UE4/3.UE4-FString/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/UE4/3.UE4-FString/","excerpt":"","text":"字符串处理 https://docs.unrealengine.com/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/index.html FName 不区分大小写 123456789FString str = FString(&quot;11111&quot;);FString str1 = FString::FromInt(1000);std::string s = std::to_string(12.0);FString str2 = FString(s.c_str());FString str3 = &quot;11111&quot;;FString str4 = TEXT(&quot;11111&quot;);FString str5 = FString::Printf(TEXT(&quot;TEXT%hs&quot;),&quot;1111&quot;);FString str6 = FString::Printf(TEXT(&quot;TEXT%d&quot;),1111);FString str7 = FString::Printf(TEXT(&quot;TEXT%f&quot;),1111.0f);","categories":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/categories/UE4/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/tags/UE4/"}]},{"title":"2.UE4-新建工程","slug":"UE4/2.UE4-新建工程","date":"2021-06-11T05:43:00.000Z","updated":"2021-06-11T07:46:32.713Z","comments":true,"path":"2021/06/11/UE4/2.UE4-新建工程/","link":"","permalink":"https://leolichenxi.github.io/2021/06/11/UE4/2.UE4-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"新建工程NOTE_PROJECThttps://ue4community.wiki/logging-lgpidy6i 123456789 UE_LOG(LogTemp,Log,TEXT(&quot;1111111111Warning&quot;))UE_LOG(LogTemp,Warning,TEXT(&quot;1111111111Warning&quot;))UE_LOG(LogTemp,Error,TEXT(&quot;1111111111Warning&quot;))UE_LOG(CustomLog,Error,TEXT(&quot;1111111111Warning&quot;))GEngine-&gt; AddOnScreenDebugMessage(-1,1,FColor::Red,&quot;AddOnScreenDebugMessage&quot;);LOG_SCREEN(&quot;LOG_SCREEN&quot;) 自定义： 在.h文件中DECLARE_LOG_CATEGORY_EXTERN(CustomLog, Log, All);在.cpp文件中DEFINE_LOG_CATEGORY(CustomLog); 定义#define LOG_SCREEN(text) if(GEngine) GEngine-&gt; AddOnScreenDebugMessage(-1,1,FColor::Red,text);","categories":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/categories/UE4/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/tags/UE4/"}]}],"categories":[{"name":"Tools","slug":"Tools","permalink":"https://leolichenxi.github.io/categories/Tools/"},{"name":"Codes","slug":"Codes","permalink":"https://leolichenxi.github.io/categories/Codes/"},{"name":"U3D","slug":"U3D","permalink":"https://leolichenxi.github.io/categories/U3D/"},{"name":"数据结构","slug":"数据结构","permalink":"https://leolichenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"开发流程","slug":"开发流程","permalink":"https://leolichenxi.github.io/categories/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"name":"ShaderLab","slug":"ShaderLab","permalink":"https://leolichenxi.github.io/categories/ShaderLab/"},{"name":"lua","slug":"lua","permalink":"https://leolichenxi.github.io/categories/lua/"},{"name":"shell","slug":"shell","permalink":"https://leolichenxi.github.io/categories/shell/"},{"name":"基础","slug":"基础","permalink":"https://leolichenxi.github.io/categories/%E5%9F%BA%E7%A1%80/"},{"name":"Hexo","slug":"Hexo","permalink":"https://leolichenxi.github.io/categories/Hexo/"},{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/categories/UE4/"}],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://leolichenxi.github.io/tags/JetBrains/"},{"name":"VSCode","slug":"VSCode","permalink":"https://leolichenxi.github.io/tags/VSCode/"},{"name":"adb","slug":"adb","permalink":"https://leolichenxi.github.io/tags/adb/"},{"name":"Codes","slug":"Codes","permalink":"https://leolichenxi.github.io/tags/Codes/"},{"name":"框架","slug":"框架","permalink":"https://leolichenxi.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"其它","slug":"其它","permalink":"https://leolichenxi.github.io/tags/%E5%85%B6%E5%AE%83/"},{"name":"Charp Lua","slug":"Charp-Lua","permalink":"https://leolichenxi.github.io/tags/Charp-Lua/"},{"name":"CMake","slug":"CMake","permalink":"https://leolichenxi.github.io/tags/CMake/"},{"name":"算法","slug":"算法","permalink":"https://leolichenxi.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"GoogleProtobuffer","slug":"GoogleProtobuffer","permalink":"https://leolichenxi.github.io/tags/GoogleProtobuffer/"},{"name":"开发流程","slug":"开发流程","permalink":"https://leolichenxi.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"name":"builtin_shaders","slug":"builtin-shaders","permalink":"https://leolichenxi.github.io/tags/builtin-shaders/"},{"name":"AAB","slug":"AAB","permalink":"https://leolichenxi.github.io/tags/AAB/"},{"name":"优化","slug":"优化","permalink":"https://leolichenxi.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"资源","slug":"资源","permalink":"https://leolichenxi.github.io/tags/%E8%B5%84%E6%BA%90/"},{"name":"lua","slug":"lua","permalink":"https://leolichenxi.github.io/tags/lua/"},{"name":"工具","slug":"工具","permalink":"https://leolichenxi.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"shell","slug":"shell","permalink":"https://leolichenxi.github.io/tags/shell/"},{"name":"基础","slug":"基础","permalink":"https://leolichenxi.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"pure","slug":"pure","permalink":"https://leolichenxi.github.io/tags/pure/"},{"name":"UE4","slug":"UE4","permalink":"https://leolichenxi.github.io/tags/UE4/"},{"name":"hexo","slug":"hexo","permalink":"https://leolichenxi.github.io/tags/hexo/"}]}